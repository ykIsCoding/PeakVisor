import * as i0 from '@angular/core';
import { InjectionToken, APP_INITIALIZER, NgModule } from '@angular/core';
import { makeStateKey, TransferState } from '@angular/platform-browser';
import { join } from 'path';
import { transformAnimationFilenameToKey } from 'ngx-lottie';
import { readFile } from 'fs';

/** A simple cache used to store the serialized animation data. */
const cache = new Map();
function readFileWithAnimationData(path) {
    return cache.has(path)
        ? Promise.resolve(cache.get(path))
        : new Promise((resolve, reject) => {
            readFile(path, (error, buffer) => {
                if (error) {
                    reject(error);
                }
                else {
                    const data = buffer.toString();
                    cache.set(path, data);
                    resolve(data);
                }
            });
        });
}

function readAndTransferAnimationData(transferState, animations, pathsToAnimations) {
    const sources = [];
    for (let i = 0, length = animations.length; i < length; i++) {
        const path = pathsToAnimations[i];
        const source = readFileWithAnimationData(path)
            .then(animationData => {
            transferAnimationData(transferState, animations[i], animationData);
        })
            .catch(error => {
            if (typeof ngDevMode === 'undefined' || ngDevMode) {
                console.error(`Failed to read the following file ${path}. Error: `, error);
            }
            // This is empty since we don't have to do anything if the file was failed to read.
        });
        sources.push(source);
    }
    return sources;
}
function transferAnimationData(state, animation, animationData) {
    animation = transformAnimationFilenameToKey(animation);
    const key = makeStateKey(animation);
    state.set(key, JSON.parse(animationData));
}
function appInitializerFactory(options, state) {
    const pathsToAnimations = resolveLottiePaths(options);
    const sources = readAndTransferAnimationData(state, options.preloadAnimations.animations, pathsToAnimations);
    return () => Promise.all(sources);
}
function resolveLottiePaths({ preloadAnimations }) {
    const { folder, animations } = preloadAnimations;
    const path = join(process.cwd(), folder);
    return animations.map(animation => join(path, animation));
}

const LOTTIE_SERVER_OPTIONS = new InjectionToken('LottieServerOptions');
class LottieServerModule {
    static forRoot(options) {
        return {
            ngModule: LottieServerModule,
            providers: [
                {
                    provide: LOTTIE_SERVER_OPTIONS,
                    useValue: options,
                },
                {
                    provide: APP_INITIALIZER,
                    useFactory: appInitializerFactory,
                    multi: true,
                    deps: [LOTTIE_SERVER_OPTIONS, TransferState],
                },
            ],
        };
    }
}
/** @nocollapse */ LottieServerModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.0.0", ngImport: i0, type: LottieServerModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
/** @nocollapse */ LottieServerModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "15.0.0", ngImport: i0, type: LottieServerModule });
/** @nocollapse */ LottieServerModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "15.0.0", ngImport: i0, type: LottieServerModule });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.0.0", ngImport: i0, type: LottieServerModule, decorators: [{
            type: NgModule
        }] });

/**
 * Generated bundle index. Do not edit.
 */

export { LottieServerModule };
//# sourceMappingURL=ngx-lottie-server.mjs.map
//# sourceMappingURL=ngx-lottie-server.mjs.map
