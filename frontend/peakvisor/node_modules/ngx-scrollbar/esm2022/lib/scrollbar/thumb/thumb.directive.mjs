import { Directive, Inject } from '@angular/core';
import { DOCUMENT } from '@angular/common';
import { ThumbAdapter } from './thumb';
import * as i0 from "@angular/core";
import * as i1 from "../../ng-scrollbar-base";
import * as i2 from "../track/track.directive";
import * as i3 from "@angular/cdk/bidi";
export class ThumbXDirective extends ThumbAdapter {
    get clientProperty() {
        return 'clientX';
    }
    get pageProperty() {
        return 'pageX';
    }
    get viewportScrollSize() {
        return this.cmp.viewport.scrollWidth;
    }
    get viewportScrollOffset() {
        return this.cmp.viewport.scrollLeft;
    }
    get viewportScrollMax() {
        return this.cmp.viewport.scrollMaxX;
    }
    get dragStartOffset() {
        return this.clientRect.left + this.document.defaultView.pageXOffset || 0;
    }
    get size() {
        return this.thumbElement.clientWidth;
    }
    constructor(cmp, track, element, document, dir) {
        super(cmp, track, element.nativeElement, document);
        this.cmp = cmp;
        this.track = track;
        this.element = element;
        this.document = document;
        this.dir = dir;
    }
    updateStyles(position, size) {
        this.thumbElement.style.width = `${size}px`;
        this.thumbElement.style.transform = `translate3d(${position}px, 0, 0)`;
    }
    handleDrag(position, scrollMax) {
        if (this.dir.value === 'rtl') {
            if (this.cmp.manager.rtlScrollAxisType === 1 /* RtlScrollAxisType.NEGATED */) {
                return position - scrollMax;
            }
            if (this.cmp.manager.rtlScrollAxisType === 2 /* RtlScrollAxisType.INVERTED */) {
                return scrollMax - position;
            }
            // Keeping this as a memo
            // if (this.rtlScrollAxisType === RtlScrollAxisType.NORMAL) {
            //   return position;
            // }
        }
        return position;
    }
    handleDirection(position, trackMax) {
        if (this.dir.value === 'rtl') {
            if (this.cmp.manager.rtlScrollAxisType === 2 /* RtlScrollAxisType.INVERTED */) {
                return -position;
            }
            if (this.cmp.manager.rtlScrollAxisType === 0 /* RtlScrollAxisType.NORMAL */) {
                return position - trackMax;
            }
            // Keeping this as a memo
            // if (this.rtlScrollAxisType === RtlScrollAxisType.NEGATED) {
            //   return position;
            // }
        }
        return position;
    }
    setDragging(value) {
        this.cmp.setDragging({ horizontalDragging: value });
    }
    scrollTo(position) {
        this.cmp.viewport.scrollXTo(position);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.1.5", ngImport: i0, type: ThumbXDirective, deps: [{ token: i1.NgScrollbarBase }, { token: i2.TrackXDirective }, { token: i0.ElementRef }, { token: DOCUMENT }, { token: i3.Directionality }], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "16.1.5", type: ThumbXDirective, isStandalone: true, selector: "[scrollbarThumbX]", usesInheritance: true, ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.1.5", ngImport: i0, type: ThumbXDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[scrollbarThumbX]',
                    standalone: true
                }]
        }], ctorParameters: function () { return [{ type: i1.NgScrollbarBase }, { type: i2.TrackXDirective }, { type: i0.ElementRef }, { type: Document, decorators: [{
                    type: Inject,
                    args: [DOCUMENT]
                }] }, { type: i3.Directionality }]; } });
export class ThumbYDirective extends ThumbAdapter {
    get pageProperty() {
        return 'pageY';
    }
    get viewportScrollSize() {
        return this.cmp.viewport.scrollHeight;
    }
    get viewportScrollOffset() {
        return this.cmp.viewport.scrollTop;
    }
    get viewportScrollMax() {
        return this.cmp.viewport.scrollMaxY;
    }
    get clientProperty() {
        return 'clientY';
    }
    get dragStartOffset() {
        return this.clientRect.top + this.document.defaultView.pageYOffset || 0;
    }
    get size() {
        return this.thumbElement.clientHeight;
    }
    constructor(cmp, track, element, document) {
        super(cmp, track, element.nativeElement, document);
        this.cmp = cmp;
        this.track = track;
        this.element = element;
        this.document = document;
    }
    updateStyles(position, size) {
        this.thumbElement.style.height = `${size}px`;
        this.thumbElement.style.transform = `translate3d(0px, ${position}px, 0)`;
    }
    handleDrag(position) {
        return position;
    }
    handleDirection(position) {
        return position;
    }
    setDragging(value) {
        this.cmp.setDragging({ verticalDragging: value });
    }
    scrollTo(position) {
        this.cmp.viewport.scrollYTo(position);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.1.5", ngImport: i0, type: ThumbYDirective, deps: [{ token: i1.NgScrollbarBase }, { token: i2.TrackYDirective }, { token: i0.ElementRef }, { token: DOCUMENT }], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "16.1.5", type: ThumbYDirective, isStandalone: true, selector: "[scrollbarThumbY]", usesInheritance: true, ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.1.5", ngImport: i0, type: ThumbYDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[scrollbarThumbY]',
                    standalone: true
                }]
        }], ctorParameters: function () { return [{ type: i1.NgScrollbarBase }, { type: i2.TrackYDirective }, { type: i0.ElementRef }, { type: Document, decorators: [{
                    type: Inject,
                    args: [DOCUMENT]
                }] }]; } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGh1bWIuZGlyZWN0aXZlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vcHJvamVjdHMvbmd4LXNjcm9sbGJhci9zcmMvbGliL3Njcm9sbGJhci90aHVtYi90aHVtYi5kaXJlY3RpdmUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLFNBQVMsRUFBRSxNQUFNLEVBQWMsTUFBTSxlQUFlLENBQUM7QUFDOUQsT0FBTyxFQUFFLFFBQVEsRUFBRSxNQUFNLGlCQUFpQixDQUFDO0FBRzNDLE9BQU8sRUFBRSxZQUFZLEVBQUUsTUFBTSxTQUFTLENBQUM7Ozs7O0FBUXZDLE1BQU0sT0FBTyxlQUFnQixTQUFRLFlBQVk7SUFFL0MsSUFBYyxjQUFjO1FBQzFCLE9BQU8sU0FBUyxDQUFDO0lBQ25CLENBQUM7SUFFRCxJQUFjLFlBQVk7UUFDeEIsT0FBTyxPQUFPLENBQUM7SUFDakIsQ0FBQztJQUVELElBQWMsa0JBQWtCO1FBQzlCLE9BQU8sSUFBSSxDQUFDLEdBQUcsQ0FBQyxRQUFTLENBQUMsV0FBVyxDQUFDO0lBQ3hDLENBQUM7SUFFRCxJQUFjLG9CQUFvQjtRQUNoQyxPQUFPLElBQUksQ0FBQyxHQUFHLENBQUMsUUFBUyxDQUFDLFVBQVUsQ0FBQztJQUN2QyxDQUFDO0lBRUQsSUFBSSxpQkFBaUI7UUFDbkIsT0FBTyxJQUFJLENBQUMsR0FBRyxDQUFDLFFBQVMsQ0FBQyxVQUFVLENBQUM7SUFDdkMsQ0FBQztJQUVELElBQUksZUFBZTtRQUNqQixPQUFPLElBQUksQ0FBQyxVQUFVLENBQUMsSUFBSSxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsV0FBWSxDQUFDLFdBQVcsSUFBSSxDQUFDLENBQUM7SUFDNUUsQ0FBQztJQUVELElBQUksSUFBSTtRQUNOLE9BQU8sSUFBSSxDQUFDLFlBQVksQ0FBQyxXQUFXLENBQUM7SUFDdkMsQ0FBQztJQUVELFlBQXNCLEdBQW9CLEVBQ3BCLEtBQXNCLEVBQ3RCLE9B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QVMsQ0FBQyxTQUFTLENBQUMsUUFBUSxDQUFDLENBQUM7SUFDekMsQ0FBQzs4R0F6RFUsZUFBZSwwR0FpQ04sUUFBUTtrR0FqQ2pCLGVBQWU7OzJGQUFmLGVBQWU7a0JBSjNCLFNBQVM7bUJBQUM7b0JBQ1QsUUFBUSxFQUFFLG1CQUFtQjtvQkFDN0IsVUFBVSxFQUFFLElBQUk7aUJBQ2pCOzswQkFrQ2MsTUFBTTsyQkFBQyxRQUFRIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRGlyZWN0aXZlLCBJbmplY3QsIEVsZW1lbnRSZWYgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgRE9DVU1FTlQgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xyXG5pbXBvcnQgeyBSdGxTY3JvbGxBeGlzVHlwZSB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9wbGF0Zm9ybSc7XHJcbmltcG9ydCB7IERpcmVjdGlvbmFsaXR5IH0gZnJvbSAnQGFuZ3VsYXIvY2RrL2JpZGknO1xyXG5pbXBvcnQgeyBUaHVtYkFkYXB0ZXIgfSBmcm9tICcuL3RodW1iJztcclxuaW1wb3J0IHsgVHJhY2tYRGlyZWN0aXZlLCBUcmFja1lEaXJlY3RpdmUgfSBmcm9tICcuLi90cmFjay90cmFjay5kaXJlY3RpdmUnO1xyXG5pbXBvcnQgeyBOZ1Njcm9sbGJhckJhc2UgfSBmcm9tICcuLi8uLi9uZy1zY3JvbGxiYXItYmFzZSc7XHJcblxyXG5ARGlyZWN0aXZlKHtcclxuICBzZWxlY3RvcjogJ1tzY3JvbGxiYXJUaHVtYlhdJyxcclxuICBzdGFuZGFsb25lOiB0cnVlXHJcbn0pXHJcbmV4cG9ydCBjbGFzcyBUaHVtYlhEaXJlY3RpdmUgZXh0ZW5kcyBUaHVtYkFkYXB0ZXIge1xyXG5cclxuICBwcm90ZWN0ZWQgZ2V0IGNsaWVudFByb3BlcnR5KCk6IHN0cmluZyB7XHJcbiAgICByZXR1cm4gJ2NsaWVudFgnO1xyXG4gIH1cclxuXHJcbiAgcHJvdGVjdGVkIGdldCBwYWdlUHJvcGVydHkoKTogc3RyaW5nIHtcclxuICAgIHJldHVybiAncGFnZVgnO1xyXG4gIH1cclxuXHJcbiAgcHJvdGVjdGVkIGdldCB2aWV3cG9ydFNjcm9sbFNpemUoKTogbnVtYmVyIHtcclxuICAgIHJldHVybiB0aGlzLmNtcC52aWV3cG9ydCEuc2Nyb2xsV2lkdGg7XHJcbiAgfVxyXG5cclxuICBwcm90ZWN0ZWQgZ2V0IHZpZXdwb3J0U2Nyb2xsT2Zmc2V0KCk6IG51bWJlciB7XHJcbiAgICByZXR1cm4gdGhpcy5jbXAudmlld3BvcnQhLnNjcm9sbExlZnQ7XHJcbiAgfVxyXG5cclxuICBnZXQgdmlld3BvcnRTY3JvbGxNYXgoKTogbnVtYmVyIHtcclxuICAgIHJldHVybiB0aGlzLmNtcC52aWV3cG9ydCEuc2Nyb2xsTWF4WDtcclxuICB9XHJcblxyXG4gIGdldCBkcmFnU3RhcnRPZmZzZXQoKTogbnVtYmVyIHtcclxuICAgIHJldHVybiB0aGlzLmNsaWVudFJlY3QubGVmdCArIHRoaXMuZG9jdW1lbnQuZGVmYXVsdFZpZXchLnBhZ2VYT2Zmc2V0IHx8IDA7XHJcbiAgfVxyXG5cclxuICBnZXQgc2l6ZSgpOiBudW1iZXIge1xyXG4gICAgcmV0dXJuIHRoaXMudGh1bWJFbGVtZW50LmNsaWVudFdpZHRoO1xyXG4gIH1cclxuXHJcbiAgY29uc3RydWN0b3IocHJvdGVjdGVkIGNtcDogTmdTY3JvbGxiYXJCYXNlLFxyXG4gICAgICAgICAgICAgIHByb3RlY3RlZCB0cmFjazogVHJhY2tYRGlyZWN0aXZlLFxyXG4gICAgICAgICAgICAgIHByb3RlY3RlZCBlbGVtZW50OiBFbGVtZW50UmVmLFxyXG4gICAgICAgICAgICAgIEBJbmplY3QoRE9DVU1FTlQpIHByb3RlY3RlZCBkb2N1bWVudDogRG9jdW1lbnQsXHJcbiAgICAgICAgICAgICAgcHJvdGVjdGVkIGRpcjogRGlyZWN0aW9uYWxpdHkpIHtcclxuICAgIHN1cGVyKGNtcCwgdHJhY2ssIGVsZW1lbnQubmF0aXZlRWxlbWVudCwgZG9jdW1lbnQpO1xyXG4gIH1cclxuXHJcbiAgcHJvdGVjdGVkIHVwZGF0ZVN0eWxlcyhwb3NpdGlvbjogbnVtYmVyLCBzaXplOiBudW1iZXIpIHtcclxuICAgIHRoaXMudGh1bWJFbGVtZW50LnN0eWxlLndpZHRoID0gYCR7IHNpemUgfXB4YDtcclxuICAgIHRoaXMudGh1bWJFbGVtZW50LnN0eWxlLnRyYW5zZm9ybSA9IGB0cmFuc2xhdGUzZCgkeyBwb3NpdGlvbiB9cHgsIDAsIDApYDtcclxuICB9XHJcblxyXG4gIHByb3RlY3RlZCBoYW5kbGVEcmFnKHBvc2l0aW9uOiBudW1iZXIsIHNjcm9sbE1heDogbnVtYmVyKTogbnVtYmVyIHtcclxuICAgIGlmICh0aGlzLmRpci52YWx1ZSA9PT0gJ3J0bCcpIHtcclxuICAgICAgaWYgKHRoaXMuY21wLm1hbmFnZXIucnRsU2Nyb2xsQXhpc1R5cGUgPT09IFJ0bFNjcm9sbEF4aXNUeXBlLk5FR0FURUQpIHtcclxuICAgICAgICByZXR1cm4gcG9zaXRpb24gLSBzY3JvbGxNYXg7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHRoaXMuY21wLm1hbmFnZXIucnRsU2Nyb2xsQXhpc1R5cGUgPT09IFJ0bFNjcm9sbEF4aXNUeXBlLklOVkVSVEVEKSB7XHJcbiAgICAgICAgcmV0dXJuIHNjcm9sbE1heCAtIHBvc2l0aW9uO1xyXG4gICAgICB9XHJcbiAgICAgIC8vIEtlZXBpbmcgdGhpcyBhcyBhIG1lbW9cclxuICAgICAgLy8gaWYgKHRoaXMucnRsU2Nyb2xsQXhpc1R5cGUgPT09IFJ0bFNjcm9sbEF4aXNUeXBlLk5PUk1BTCkge1xyXG4gICAgICAvLyAgIHJldHVybiBwb3NpdGlvbjtcclxuICAgICAgLy8gfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHBvc2l0aW9uO1xyXG4gIH1cclxuXHJcbiAgcHJvdGVjdGVkIGhhbmRsZURpcmVjdGlvbihwb3NpdGlvbjogbnVtYmVyLCB0cmFja01heDogbnVtYmVyKTogbnVtYmVyIHtcclxuICAgIGlmICh0aGlzLmRpci52YWx1ZSA9PT0gJ3J0bCcpIHtcclxuICAgICAgaWYgKHRoaXMuY21wLm1hbmFnZXIucnRsU2Nyb2xsQXhpc1R5cGUgPT09IFJ0bFNjcm9sbEF4aXNUeXBlLklOVkVSVEVEKSB7XHJcbiAgICAgICAgcmV0dXJuIC1wb3NpdGlvbjtcclxuICAgICAgfVxyXG4gICAgICBpZiAodGhpcy5jbXAubWFuYWdlci5ydGxTY3JvbGxBeGlzVHlwZSA9PT0gUnRsU2Nyb2xsQXhpc1R5cGUuTk9STUFMKSB7XHJcbiAgICAgICAgcmV0dXJuIHBvc2l0aW9uIC0gdHJhY2tNYXg7XHJcbiAgICAgIH1cclxuICAgICAgLy8gS2VlcGluZyB0aGlzIGFzIGEgbWVtb1xyXG4gICAgICAvLyBpZiAodGhpcy5ydGxTY3JvbGxBeGlzVHlwZSA9PT0gUnRsU2Nyb2xsQXhpc1R5cGUuTkVHQVRFRCkge1xyXG4gICAgICAvLyAgIHJldHVybiBwb3NpdGlvbjtcclxuICAgICAgLy8gfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHBvc2l0aW9uO1xyXG4gIH1cclxuXHJcbiAgcHJvdGVjdGVkIHNldERyYWdnaW5nKHZhbHVlOiBib29sZWFuKTogdm9pZCB7XHJcbiAgICB0aGlzLmNtcC5zZXREcmFnZ2luZyh7IGhvcml6b250YWxEcmFnZ2luZzogdmFsdWUgfSk7XHJcbiAgfVxyXG5cclxuICBwcm90ZWN0ZWQgc2Nyb2xsVG8ocG9zaXRpb246IG51bWJlcik6IHZvaWQge1xyXG4gICAgdGhpcy5jbXAudmlld3BvcnQhLnNjcm9sbFhUbyhwb3NpdGlvbik7XHJcbiAgfVxyXG59XHJcblxyXG5ARGlyZWN0aXZlKHtcclxuICBzZWxlY3RvcjogJ1tzY3JvbGxiYXJUaHVtYlldJyxcclxuICBzdGFuZGFsb25lOiB0cnVlXHJcbn0pXHJcbmV4cG9ydCBjbGFzcyBUaHVtYllEaXJlY3RpdmUgZXh0ZW5kcyBUaHVtYkFkYXB0ZXIge1xyXG5cclxuICBwcm90ZWN0ZWQgZ2V0IHBhZ2VQcm9wZXJ0eSgpOiBzdHJpbmcge1xyXG4gICAgcmV0dXJuICdwYWdlWSc7XHJcbiAgfVxyXG5cclxuICBwcm90ZWN0ZWQgZ2V0IHZpZXdwb3J0U2Nyb2xsU2l6ZSgpOiBudW1iZXIge1xyXG4gICAgcmV0dXJuIHRoaXMuY21wLnZpZXdwb3J0IS5zY3JvbGxIZWlnaHQ7XHJcbiAgfVxyXG5cclxuICBwcm90ZWN0ZWQgZ2V0IHZpZXdwb3J0U2Nyb2xsT2Zmc2V0KCk6IG51bWJlciB7XHJcbiAgICByZXR1cm4gdGhpcy5jbXAudmlld3BvcnQhLnNjcm9sbFRvcDtcclxuICB9XHJcblxyXG4gIGdldCB2aWV3cG9ydFNjcm9sbE1heCgpOiBudW1iZXIge1xyXG4gICAgcmV0dXJuIHRoaXMuY21wLnZpZXdwb3J0IS5zY3JvbGxNYXhZO1xyXG4gIH1cclxuXHJcbiAgcHJvdGVjdGVkIGdldCBjbGllbnRQcm9wZXJ0eSgpOiBzdHJpbmcge1xyXG4gICAgcmV0dXJuICdjbGllbnRZJztcclxuICB9XHJcblxyXG4gIGdldCBkcmFnU3RhcnRPZmZzZXQoKTogbnVtYmVyIHtcclxuICAgIHJldHVybiB0aGlzLmNsaWVudFJlY3QudG9wICsgdGhpcy5kb2N1bWVudC5kZWZhdWx0VmlldyEucGFnZVlPZmZzZXQgfHwgMDtcclxuICB9XHJcblxyXG4gIGdldCBzaXplKCk6IG51bWJlciB7XHJcbiAgICByZXR1cm4gdGhpcy50aHVtYkVsZW1lbnQuY2xpZW50SGVpZ2h0O1xyXG4gIH1cclxuXHJcbiAgY29uc3RydWN0b3IocHJvdGVjdGVkIGNtcDogTmdTY3JvbGxiYXJCYXNlLFxyXG4gICAgICAgICAgICAgIHByb3RlY3RlZCB0cmFjazogVHJhY2tZRGlyZWN0aXZlLFxyXG4gICAgICAgICAgICAgIHByb3RlY3RlZCBlbGVtZW50OiBFbGVtZW50UmVmLFxyXG4gICAgICAgICAgICAgIEBJbmplY3QoRE9DVU1FTlQpIHByb3RlY3RlZCBkb2N1bWVudDogRG9jdW1lbnQpIHtcclxuICAgIHN1cGVyKGNtcCwgdHJhY2ssIGVsZW1lbnQubmF0aXZlRWxlbWVudCwgZG9jdW1lbnQpO1xyXG4gIH1cclxuXHJcblxyXG4gIHByb3RlY3RlZCB1cGRhdGVTdHlsZXMocG9zaXRpb246IG51bWJlciwgc2l6ZTogbnVtYmVyKTogdm9pZCB7XHJcbiAgICB0aGlzLnRodW1iRWxlbWVudC5zdHlsZS5oZWlnaHQgPSBgJHsgc2l6ZSB9cHhgO1xyXG4gICAgdGhpcy50aHVtYkVsZW1lbnQuc3R5bGUudHJhbnNmb3JtID0gYHRyYW5zbGF0ZTNkKDBweCwgJHsgcG9zaXRpb24gfXB4LCAwKWA7XHJcbiAgfVxyXG5cclxuICBwcm90ZWN0ZWQgaGFuZGxlRHJhZyhwb3NpdGlvbjogbnVtYmVyKTogbnVtYmVyIHtcclxuICAgIHJldHVybiBwb3NpdGlvbjtcclxuICB9XHJcblxyXG4gIHByb3RlY3RlZCBoYW5kbGVEaXJlY3Rpb24ocG9zaXRpb246IG51bWJlcik6IG51bWJlciB7XHJcbiAgICByZXR1cm4gcG9zaXRpb247XHJcbiAgfVxyXG5cclxuICBwcm90ZWN0ZWQgc2V0RHJhZ2dpbmcodmFsdWU6IGJvb2xlYW4pOiB2b2lkIHtcclxuICAgIHRoaXMuY21wLnNldERyYWdnaW5nKHsgdmVydGljYWxEcmFnZ2luZzogdmFsdWUgfSk7XHJcbiAgfVxyXG5cclxuICBwcm90ZWN0ZWQgc2Nyb2xsVG8ocG9zaXRpb246IG51bWJlcik6IHZvaWQge1xyXG4gICAgdGhpcy5jbXAudmlld3BvcnQhLnNjcm9sbFlUbyhwb3NpdGlvbik7XHJcbiAgfVxyXG59XHJcbiJdfQ==