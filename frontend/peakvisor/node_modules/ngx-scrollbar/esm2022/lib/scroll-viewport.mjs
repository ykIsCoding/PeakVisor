import { Directive } from '@angular/core';
import { Observable, fromEvent, merge, map, switchMap, takeUntil, tap } from 'rxjs';
import { stopPropagation } from './scrollbar/common';
import * as i0 from "@angular/core";
export class ScrollViewport {
    // Get viewport size, clientHeight or clientWidth
    get clientHeight() {
        return this.nativeElement.clientHeight;
    }
    get clientWidth() {
        return this.nativeElement.clientWidth;
    }
    get scrollHeight() {
        return this.nativeElement.scrollHeight;
    }
    get scrollWidth() {
        return this.nativeElement.scrollWidth;
    }
    // Get viewport scroll offset, scrollTop or scrollLeft
    get scrollTop() {
        return this.nativeElement.scrollTop;
    }
    get scrollLeft() {
        return this.nativeElement.scrollLeft;
    }
    // Get the available scrollable size
    get scrollMaxX() {
        return this.scrollWidth - this.clientWidth;
    }
    get scrollMaxY() {
        return this.scrollHeight - this.clientHeight;
    }
    get contentHeight() {
        return this.contentWrapperElement?.clientHeight || 0;
    }
    get contentWidth() {
        return this.contentWrapperElement?.clientWidth || 0;
    }
    constructor(viewPort) {
        this.viewPort = viewPort;
        this.nativeElement = viewPort.nativeElement;
    }
    /**
     * Activate viewport pointer events such as 'hovered' and 'clicked' events
     */
    activatePointerEvents(propagate, destroyed) {
        this.hovered = new Observable((subscriber) => {
            // Stream that emits when pointer is moved over the viewport (used to set the hovered state)
            const mouseMoveStream = fromEvent(this.nativeElement, 'mousemove', { passive: true });
            const mouseMove = propagate ? mouseMoveStream : mouseMoveStream.pipe(stopPropagation());
            // Stream that emits when pointer leaves the viewport (used to remove the hovered state)
            const mouseLeave = fromEvent(this.nativeElement, 'mouseleave', { passive: true }).pipe(map(() => false));
            merge(mouseMove, mouseLeave).pipe(tap((e) => subscriber.next(e)), takeUntil(destroyed)).subscribe();
        });
        this.clicked = new Observable((subscriber) => {
            const mouseDown = fromEvent(this.nativeElement, 'mousedown', { passive: true }).pipe(tap((e) => subscriber.next(e)));
            const mouseUp = fromEvent(this.nativeElement, 'mouseup', { passive: true }).pipe(tap(() => subscriber.next(false)));
            mouseDown.pipe(switchMap(() => mouseUp), takeUntil(destroyed)).subscribe();
        });
    }
    /**
     * Set this directive as a non-functional wrapper, called when a custom viewport is used
     */
    setAsWrapper() {
        // In this case the default viewport and the default content wrapper will act as a mask
        this.nativeElement.className = 'ng-native-scrollbar-hider ng-scroll-layer';
        if (this.nativeElement.firstElementChild) {
            this.nativeElement.firstElementChild.className = 'ng-scroll-layer';
        }
    }
    /**
     * Set this directive as  the viewport, called when no custom viewport is used
     */
    setAsViewport(customClassName) {
        this.nativeElement.className += ` ng-native-scrollbar-hider ng-scroll-viewport ${customClassName}`;
        // Check if the custom viewport has only one child and set it as the content wrapper
        if (this.nativeElement.firstElementChild) {
            this.contentWrapperElement = this.nativeElement.firstElementChild;
            this.contentWrapperElement.classList.add('ng-scroll-content');
        }
    }
    /**
     * Scroll viewport vertically
     */
    scrollYTo(value) {
        this.nativeElement.scrollTop = value;
    }
    /**
     * Scroll viewport horizontally
     */
    scrollXTo(value) {
        this.nativeElement.scrollLeft = value;
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.1.5", ngImport: i0, type: ScrollViewport, deps: [{ token: i0.ElementRef }], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "16.1.5", type: ScrollViewport, isStandalone: true, selector: "[scrollViewport]", ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.1.5", ngImport: i0, type: ScrollViewport, decorators: [{
            type: Directive,
            args: [{
                    selector: '[scrollViewport]',
                    standalone: true
                }]
        }], ctorParameters: function () { return [{ type: i0.ElementRef }]; } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2Nyb2xsLXZpZXdwb3J0LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vcHJvamVjdHMvbmd4LXNjcm9sbGJhci9zcmMvbGliL3Njcm9sbC12aWV3cG9ydC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsU0FBUyxFQUFjLE1BQU0sZUFBZSxDQUFDO0FBQ3RELE9BQU8sRUFBRSxVQUFVLEVBQWMsU0FBUyxFQUFFLEtBQUssRUFBRSxHQUFHLEVBQUUsU0FBUyxFQUFFLFNBQVMsRUFBRSxHQUFHLEVBQUUsTUFBTSxNQUFNLENBQUM7QUFDaEcsT0FBTyxFQUFFLGVBQWUsRUFBRSxNQUFNLG9CQUFvQixDQUFDOztBQU1yRCxNQUFNLE9BQU8sY0FBYztJQVd6QixpREFBaUQ7SUFDakQsSUFBSSxZQUFZO1FBQ2QsT0FBTyxJQUFJLENBQUMsYUFBYSxDQUFDLFlBQVksQ0FBQztJQUN6QyxDQUFDO0lBRUQsSUFBSSxXQUFXO1FBQ2IsT0FBTyxJQUFJLENBQUMsYUFBYSxDQUFDLFdBQVcsQ0FBQztJQUN4QyxDQUFDO0lBRUQsSUFBSSxZQUFZO1FBQ2QsT0FBTyxJQUFJLENBQUMsYUFBYSxDQUFDLFlBQVksQ0FBQztJQUN6QyxDQUFDO0lBRUQsSUFBSSxXQUFXO1FBQ2IsT0FBTyxJQUFJLENBQUMsYUFBYSxDQUFDLFdBQVcsQ0FBQztJQUN4QyxDQUFDO0lBRUQsc0RBQXNEO0lBQ3RELElBQUksU0FBUztRQUNYLE9BQU8sSUFBSSxDQUFDLGFBQWEsQ0FBQyxTQUFTLENBQUM7SUFDdEMsQ0FBQztJQUVELElBQUksVUFBVTtRQUNaLE9BQU8sSUFBSSxDQUFDLGFBQWEsQ0FBQyxVQUFVLENBQUM7SUFDdkMsQ0FBQztJQUVELG9DQUFvQztJQUNwQyxJQUFJLFVBQVU7UUFDWixPQUFPLElBQUksQ0FBQyxXQUFXLEdBQUcsSUFBSSxDQUFDLFdBQVcsQ0FBQztJQUM3QyxDQUFDO0lBRUQsSUFBSSxVQUFVO1FBQ1osT0FBTyxJ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YUFBYSxDQUFDLFNBQVMsSUFBSSxpREFBa0QsZUFBZ0IsRUFBRSxDQUFDO1FBQ3JHLG9GQUFvRjtRQUNwRixJQUFJLElBQUksQ0FBQyxhQUFhLENBQUMsaUJBQWlCLEVBQUU7WUFDeEMsSUFBSSxDQUFDLHFCQUFxQixHQUFHLElBQUksQ0FBQyxhQUFhLENBQUMsaUJBQWdDLENBQUM7WUFDakYsSUFBSSxDQUFDLHFCQUFxQixDQUFDLFNBQVMsQ0FBQyxHQUFHLENBQUMsbUJBQW1CLENBQUMsQ0FBQztTQUMvRDtJQUNILENBQUM7SUFFRDs7T0FFRztJQUNILFNBQVMsQ0FBQyxLQUFhO1FBQ3JCLElBQUksQ0FBQyxhQUFhLENBQUMsU0FBUyxHQUFHLEtBQUssQ0FBQztJQUN2QyxDQUFDO0lBRUQ7O09BRUc7SUFDSCxTQUFTLENBQUMsS0FBYTtRQUNyQixJQUFJLENBQUMsYUFBYSxDQUFDLFVBQVUsR0FBRyxLQUFLLENBQUM7SUFDeEMsQ0FBQzs4R0EzSFUsY0FBYztrR0FBZCxjQUFjOzsyRkFBZCxjQUFjO2tCQUoxQixTQUFTO21CQUFDO29CQUNULFFBQVEsRUFBRSxrQkFBa0I7b0JBQzVCLFVBQVUsRUFBRSxJQUFJO2lCQUNqQiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IERpcmVjdGl2ZSwgRWxlbWVudFJlZiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBPYnNlcnZhYmxlLCBTdWJzY3JpYmVyLCBmcm9tRXZlbnQsIG1lcmdlLCBtYXAsIHN3aXRjaE1hcCwgdGFrZVVudGlsLCB0YXAgfSBmcm9tICdyeGpzJztcclxuaW1wb3J0IHsgc3RvcFByb3BhZ2F0aW9uIH0gZnJvbSAnLi9zY3JvbGxiYXIvY29tbW9uJztcclxuXHJcbkBEaXJlY3RpdmUoe1xyXG4gIHNlbGVjdG9yOiAnW3Njcm9sbFZpZXdwb3J0XScsXHJcbiAgc3RhbmRhbG9uZTogdHJ1ZVxyXG59KVxyXG5leHBvcnQgY2xhc3MgU2Nyb2xsVmlld3BvcnQge1xyXG4gIC8vIFZpZXdwb3J0IGVsZW1lbnRcclxuICByZWFkb25seSBuYXRpdmVFbGVtZW50OiBIVE1MRWxlbWVudDtcclxuICAvLyBDb250ZW50IHdyYXBwZXIgZWxlbWVudFxyXG4gIGNvbnRlbnRXcmFwcGVyRWxlbWVudCE6IEhUTUxFbGVtZW50O1xyXG5cclxuICAvLyBTdHJlYW0gdGhhdCBlbWl0cyB3aGVuIHBvaW50ZXIgZXZlbnQgd2hlbiB0aGUgdmlld3BvcnQgaXMgaG92ZXJlZCBhbmQgZW1pdHMgZmFsc2UgdmFsdWUgd2hlbiBpc24ndCBob3ZlcmVkXHJcbiAgaG92ZXJlZCE6IE9ic2VydmFibGU8TW91c2VFdmVudCB8IGZhbHNlPjtcclxuICAvLyBTdHJlYW0gdGhhdCBlbWl0cyB3aGVuIHZpZXdwb3J0IGlzIGNsaWNrZWRcclxuICBjbGlja2VkITogT2JzZXJ2YWJsZTxNb3VzZUV2ZW50IHwgZmFsc2U+O1xyXG5cclxuICAvLyBHZXQgdmlld3BvcnQgc2l6ZSwgY2xpZW50SGVpZ2h0IG9yIGNsaWVudFdpZHRoXHJcbiAgZ2V0IGNsaWVudEhlaWdodCgpOiBudW1iZXIge1xyXG4gICAgcmV0dXJuIHRoaXMubmF0aXZlRWxlbWVudC5jbGllbnRIZWlnaHQ7XHJcbiAgfVxyXG5cclxuICBnZXQgY2xpZW50V2lkdGgoKTogbnVtYmVyIHtcclxuICAgIHJldHVybiB0aGlzLm5hdGl2ZUVsZW1lbnQuY2xpZW50V2lkdGg7XHJcbiAgfVxyXG5cclxuICBnZXQgc2Nyb2xsSGVpZ2h0KCk6IG51bWJlciB7XHJcbiAgICByZXR1cm4gdGhpcy5uYXRpdmVFbGVtZW50LnNjcm9sbEhlaWdodDtcclxuICB9XHJcblxyXG4gIGdldCBzY3JvbGxXaWR0aCgpOiBudW1iZXIge1xyXG4gICAgcmV0dXJuIHRoaXMubmF0aXZlRWxlbWVudC5zY3JvbGxXaWR0aDtcclxuICB9XHJcblxyXG4gIC8vIEdldCB2aWV3cG9ydCBzY3JvbGwgb2Zmc2V0LCBzY3JvbGxUb3Agb3Igc2Nyb2xsTGVmdFxyXG4gIGdldCBzY3JvbGxUb3AoKTogbnVtYmVyIHtcclxuICAgIHJldHVybiB0aGlzLm5hdGl2ZUVsZW1lbnQuc2Nyb2xsVG9wO1xyXG4gIH1cclxuXHJcbiAgZ2V0IHNjcm9sbExlZnQoKTogbnVtYmVyIHtcclxuICAgIHJldHVybiB0aGlzLm5hdGl2ZUVsZW1lbnQuc2Nyb2xsTGVmdDtcclxuICB9XHJcblxyXG4gIC8vIEdldCB0aGUgYXZhaWxhYmxlIHNjcm9sbGFibGUgc2l6ZVxyXG4gIGdldCBzY3JvbGxNYXhYKCk6IG51bWJlciB7XHJcbiAgICByZXR1cm4gdGhpcy5zY3JvbGxXaWR0aCAtIHRoaXMuY2xpZW50V2lkdGg7XHJcbiAgfVxyXG5cclxuICBnZXQgc2Nyb2xsTWF4WSgpOiBudW1iZXIge1xyXG4gICAgcmV0dXJuIHRoaXMuc2Nyb2xsSGVpZ2h0IC0gdGhpcy5jbGllbnRIZWlnaHQ7XHJcbiAgfVxyXG5cclxuICBnZXQgY29udGVudEhlaWdodCgpOiBudW1iZXIge1xyXG4gICAgcmV0dXJuIHRoaXMuY29udGVudFdyYXBwZXJFbGVtZW50Py5jbGllbnRIZWlnaHQgfHwgMDtcclxuICB9XHJcblxyXG4gIGdldCBjb250ZW50V2lkdGgoKTogbnVtYmVyIHtcclxuICAgIHJldHVybiB0aGlzLmNvbnRlbnRXcmFwcGVyRWxlbWVudD8uY2xpZW50V2lkdGggfHwgMDtcclxuICB9XHJcblxyXG4gIGNvbnN0cnVjdG9yKHB1YmxpYyB2aWV3UG9ydDogRWxlbWVudFJlZikge1xyXG4gICAgdGhpcy5uYXRpdmVFbGVtZW50ID0gdmlld1BvcnQubmF0aXZlRWxlbWVudDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEFjdGl2YXRlIHZpZXdwb3J0IHBvaW50ZXIgZXZlbnRzIHN1Y2ggYXMgJ2hvdmVyZWQnIGFuZCAnY2xpY2tlZCcgZXZlbnRzXHJcbiAgICovXHJcbiAgYWN0aXZhdGVQb2ludGVyRXZlbnRzKHByb3BhZ2F0ZTogYm9vbGVhbiwgZGVzdHJveWVkOiBPYnNlcnZhYmxlPHZvaWQ+KTogdm9pZCB7XHJcbiAgICB0aGlzLmhvdmVyZWQgPSBuZXcgT2JzZXJ2YWJsZSgoc3Vic2NyaWJlcjogU3Vic2NyaWJlcjxNb3VzZUV2ZW50IHwgZmFsc2U+KSA9PiB7XHJcbiAgICAgIC8vIFN0cmVhbSB0aGF0IGVtaXRzIHdoZW4gcG9pbnRlciBpcyBtb3ZlZCBvdmVyIHRoZSB2aWV3cG9ydCAodXNlZCB0byBzZXQgdGhlIGhvdmVyZWQgc3RhdGUpXHJcbiAgICAgIGNvbnN0IG1vdXNlTW92ZVN0cmVhbSA9IGZyb21FdmVudDxNb3VzZUV2ZW50Pih0aGlzLm5hdGl2ZUVsZW1lbnQsICdtb3VzZW1vdmUnLCB7IHBhc3NpdmU6IHRydWUgfSk7XHJcbiAgICAgIGNvbnN0IG1vdXNlTW92ZSA9IHByb3BhZ2F0ZSA/IG1vdXNlTW92ZVN0cmVhbSA6IG1vdXNlTW92ZVN0cmVhbS5waXBlKHN0b3BQcm9wYWdhdGlvbigpKTtcclxuICAgICAgLy8gU3RyZWFtIHRoYXQgZW1pdHMgd2hlbiBwb2ludGVyIGxlYXZlcyB0aGUgdmlld3BvcnQgKHVzZWQgdG8gcmVtb3ZlIHRoZSBob3ZlcmVkIHN0YXRlKVxyXG4gICAgICBjb25zdCBtb3VzZUxlYXZlID0gZnJvbUV2ZW50PGZhbHNlPih0aGlzLm5hdGl2ZUVsZW1lbnQsICdtb3VzZWxlYXZlJywgeyBwYXNzaXZlOiB0cnVlIH0pLnBpcGUobWFwKCgpID0+IGZhbHNlKSk7XHJcbiAgICAgIG1lcmdlKG1vdXNlTW92ZSwgbW91c2VMZWF2ZSkucGlwZShcclxuICAgICAgICB0YXAoKGU6IE1vdXNlRXZlbnQgfCBmYWxzZSkgPT4gc3Vic2NyaWJlci5uZXh0KGUpKSxcclxuICAgICAgICB0YWtlVW50aWwoZGVzdHJveWVkKVxyXG4gICAgICApLnN1YnNjcmliZSgpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgdGhpcy5jbGlja2VkID0gbmV3IE9ic2VydmFibGUoKHN1YnNjcmliZXI6IFN1YnNjcmliZXI8TW91c2VFdmVudCB8IGZhbHNlPikgPT4ge1xyXG4gICAgICBjb25zdCBtb3VzZURvd24gPSBmcm9tRXZlbnQ8TW91c2VFdmVudD4odGhpcy5uYXRpdmVFbGVtZW50LCAnbW91c2Vkb3duJywgeyBwYXNzaXZlOiB0cnVlIH0pLnBpcGUoXHJcbiAgICAgICAgdGFwKChlOiBNb3VzZUV2ZW50KSA9PiBzdWJzY3JpYmVyLm5leHQoZSkpXHJcbiAgICAgICk7XHJcbiAgICAgIGNvbnN0IG1vdXNlVXAgPSBmcm9tRXZlbnQ8ZmFsc2U+KHRoaXMubmF0aXZlRWxlbWVudCwgJ21vdXNldXAnLCB7IHBhc3NpdmU6IHRydWUgfSkucGlwZShcclxuICAgICAgICB0YXAoKCkgPT4gc3Vic2NyaWJlci5uZXh0KGZhbHNlKSlcclxuICAgICAgKTtcclxuICAgICAgbW91c2VEb3duLnBpcGUoXHJcbiAgICAgICAgc3dpdGNoTWFwKCgpID0+IG1vdXNlVXApLFxyXG4gICAgICAgIHRha2VVbnRpbChkZXN0cm95ZWQpXHJcbiAgICAgICkuc3Vic2NyaWJlKCk7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNldCB0aGlzIGRpcmVjdGl2ZSBhcyBhIG5vbi1mdW5jdGlvbmFsIHdyYXBwZXIsIGNhbGxlZCB3aGVuIGEgY3VzdG9tIHZpZXdwb3J0IGlzIHVzZWRcclxuICAgKi9cclxuICBzZXRBc1dyYXBwZXIoKTogdm9pZCB7XHJcbiAgICAvLyBJbiB0aGlzIGNhc2UgdGhlIGRlZmF1bHQgdmlld3BvcnQgYW5kIHRoZSBkZWZhdWx0IGNvbnRlbnQgd3JhcHBlciB3aWxsIGFjdCBhcyBhIG1hc2tcclxuICAgIHRoaXMubmF0aXZlRWxlbWVudC5jbGFzc05hbWUgPSAnbmctbmF0aXZlLXNjcm9sbGJhci1oaWRlciBuZy1zY3JvbGwtbGF5ZXInO1xyXG4gICAgaWYgKHRoaXMubmF0aXZlRWxlbWVudC5maXJzdEVsZW1lbnRDaGlsZCkge1xyXG4gICAgICB0aGlzLm5hdGl2ZUVsZW1lbnQuZmlyc3RFbGVtZW50Q2hpbGQuY2xhc3NOYW1lID0gJ25nLXNjcm9sbC1sYXllcic7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTZXQgdGhpcyBkaXJlY3RpdmUgYXMgIHRoZSB2aWV3cG9ydCwgY2FsbGVkIHdoZW4gbm8gY3VzdG9tIHZpZXdwb3J0IGlzIHVzZWRcclxuICAgKi9cclxuICBzZXRBc1ZpZXdwb3J0KGN1c3RvbUNsYXNzTmFtZTogc3RyaW5nKTogdm9pZCB7XHJcbiAgICB0aGlzLm5hdGl2ZUVsZW1lbnQuY2xhc3NOYW1lICs9IGAgbmctbmF0aXZlLXNjcm9sbGJhci1oaWRlciBuZy1zY3JvbGwtdmlld3BvcnQgJHsgY3VzdG9tQ2xhc3NOYW1lIH1gO1xyXG4gICAgLy8gQ2hlY2sgaWYgdGhlIGN1c3RvbSB2aWV3cG9ydCBoYXMgb25seSBvbmUgY2hpbGQgYW5kIHNldCBpdCBhcyB0aGUgY29udGVudCB3cmFwcGVyXHJcbiAgICBpZiAodGhpcy5uYXRpdmVFbGVtZW50LmZpcnN0RWxlbWVudENoaWxkKSB7XHJcbiAgICAgIHRoaXMuY29udGVudFdyYXBwZXJFbGVtZW50ID0gdGhpcy5uYXRpdmVFbGVtZW50LmZpcnN0RWxlbWVudENoaWxkIGFzIEhUTUxFbGVtZW50O1xyXG4gICAgICB0aGlzLmNvbnRlbnRXcmFwcGVyRWxlbWVudC5jbGFzc0xpc3QuYWRkKCduZy1zY3JvbGwtY29udGVudCcpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2Nyb2xsIHZpZXdwb3J0IHZlcnRpY2FsbHlcclxuICAgKi9cclxuICBzY3JvbGxZVG8odmFsdWU6IG51bWJlcik6IHZvaWQge1xyXG4gICAgdGhpcy5uYXRpdmVFbGVtZW50LnNjcm9sbFRvcCA9IHZhbHVlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2Nyb2xsIHZpZXdwb3J0IGhvcml6b250YWxseVxyXG4gICAqL1xyXG4gIHNjcm9sbFhUbyh2YWx1ZTogbnVtYmVyKTogdm9pZCB7XHJcbiAgICB0aGlzLm5hdGl2ZUVsZW1lbnQuc2Nyb2xsTGVmdCA9IHZhbHVlO1xyXG4gIH1cclxufVxyXG4iXX0=