import * as i0 from '@angular/core';
import { Directive, Optional, Input, Output, NgModule } from '@angular/core';
import { Subject, Subscription, Observable, tap, map, distinctUntilChanged, filter } from 'rxjs';
import * as i1 from 'ngx-scrollbar';
import * as i2 from '@angular/cdk/bidi';

class ReachedFunctions {
    static reachedTop(offset, e) {
        return ReachedFunctions.reached(-e.target.scrollTop, 0, offset);
    }
    static reachedBottom(offset, e) {
        return ReachedFunctions.reached(e.target.scrollTop + e.target.clientHeight, e.target.scrollHeight, offset);
    }
    static reachedStart(offset, e, direction, rtlScrollAxisType) {
        if (direction === 'rtl') {
            if (rtlScrollAxisType === 1 /* RtlScrollAxisType.NEGATED */) {
                return ReachedFunctions.reached(e.target.scrollLeft, 0, offset);
            }
            if (rtlScrollAxisType === 2 /* RtlScrollAxisType.INVERTED */) {
                return ReachedFunctions.reached(-e.target.scrollLeft, 0, offset);
            }
            return ReachedFunctions.reached(e.target.scrollLeft + e.target.clientWidth, e.target.scrollWidth, offset);
        }
        return ReachedFunctions.reached(-e.target.scrollLeft, 0, offset);
    }
    static reachedEnd(offset, e, direction, rtlScrollAxisType) {
        if (direction === 'rtl') {
            if (rtlScrollAxisType === 1 /* RtlScrollAxisType.NEGATED */) {
                return ReachedFunctions.reached(-(e.target.scrollLeft - e.target.clientWidth), e.target.scrollWidth, offset);
            }
            if (rtlScrollAxisType === 2 /* RtlScrollAxisType.INVERTED */) {
                return ReachedFunctions.reached(-(e.target.scrollLeft + e.target.clientWidth), e.target.scrollWidth, offset);
            }
            return ReachedFunctions.reached(-e.target.scrollLeft, 0, offset);
        }
        return ReachedFunctions.reached(e.target.scrollLeft + e.target.clientWidth, e.target.scrollWidth, offset);
    }
    static reached(currPosition, targetPosition, offset) {
        return currPosition >= targetPosition - offset;
    }
}
class ScrollReached {
    constructor(scrollbar, zone) {
        this.scrollbar = scrollbar;
        this.zone = zone;
        /** offset: Reached offset value in px */
        this.offset = 0;
        /**
         * Stream that emits scroll event when `NgScrollbar.scrolled` is initialized.
         *
         * **NOTE:** This subject is used to hold the place of `NgScrollbar.scrolled` when it's not initialized yet
         */
        this.scrollEvent = new Subject();
        /** subscription: Scrolled event subscription, used to unsubscribe from the event on destroy */
        this.subscription = Subscription.EMPTY;
        /** A stream used to assign the reached output */
        this.reachedEvent = new Observable((subscriber) => this.scrollReached().subscribe(_ => Promise.resolve().then(() => this.zone.run(() => subscriber.next(_)))));
        if (!scrollbar) {
            console.warn('[NgScrollbarReached Directive]: Host element must be an NgScrollbar component.');
        }
    }
    ngOnDestroy() {
        this.subscription.unsubscribe();
    }
    scrollReached() {
        // current event
        let currEvent;
        return this.scrollEvent.pipe(tap((e) => currEvent = e), 
        // Check if scroll has reached
        map((e) => this.reached(this.offset, e)), 
        // Distinct until reached value has changed
        distinctUntilChanged(), 
        // Emit only if reached is true
        filter((reached) => reached), 
        // Return scroll event
        map(() => currEvent));
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.1.5", ngImport: i0, type: ScrollReached, deps: [{ token: i1.NgScrollbar, optional: true }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "16.1.5", type: ScrollReached, inputs: { offset: ["reachedOffset", "offset"] }, ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.1.5", ngImport: i0, type: ScrollReached, decorators: [{
            type: Directive
        }], ctorParameters: function () { return [{ type: i1.NgScrollbar, decorators: [{
                    type: Optional
                }] }, { type: i0.NgZone }]; }, propDecorators: { offset: [{
                type: Input,
                args: ['reachedOffset']
            }] } });
class VerticalScrollReached extends ScrollReached {
    constructor(scrollbar, zone) {
        super(scrollbar, zone);
        this.scrollbar = scrollbar;
        this.zone = zone;
    }
    ngOnInit() {
        this.zone.runOutsideAngular(() => {
            // Fix the viewport size in case the rendered size is not rounded
            const fixedSize = Math.round(this.scrollbar.viewport.nativeElement.getBoundingClientRect().height);
            this.scrollbar.viewport.nativeElement.style.height = `${fixedSize}px`;
            this.subscription = this.scrollbar.verticalScrolled.subscribe(this.scrollEvent);
        });
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.1.5", ngImport: i0, type: VerticalScrollReached, deps: [{ token: i1.NgScrollbar, optional: true }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "16.1.5", type: VerticalScrollReached, usesInheritance: true, ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.1.5", ngImport: i0, type: VerticalScrollReached, decorators: [{
            type: Directive
        }], ctorParameters: function () { return [{ type: i1.NgScrollbar, decorators: [{
                    type: Optional
                }] }, { type: i0.NgZone }]; } });
class HorizontalScrollReached extends ScrollReached {
    constructor(scrollbar, zone) {
        super(scrollbar, zone);
        this.scrollbar = scrollbar;
        this.zone = zone;
    }
    ngOnInit() {
        this.zone.runOutsideAngular(() => {
            // Fix the viewport size in case the rendered size is not rounded
            const fixedSize = Math.round(this.scrollbar.viewport.nativeElement.getBoundingClientRect().width);
            this.scrollbar.viewport.nativeElement.style.width = `${fixedSize}px`;
            this.subscription = this.scrollbar.horizontalScrolled.subscribe(this.scrollEvent);
        });
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.1.5", ngImport: i0, type: HorizontalScrollReached, deps: [{ token: i1.NgScrollbar, optional: true }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "16.1.5", type: HorizontalScrollReached, usesInheritance: true, ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.1.5", ngImport: i0, type: HorizontalScrollReached, decorators: [{
            type: Directive
        }], ctorParameters: function () { return [{ type: i1.NgScrollbar, decorators: [{
                    type: Optional
                }] }, { type: i0.NgZone }]; } });
class NgScrollbarReachedTop extends VerticalScrollReached {
    constructor(scrollbar, zone) {
        super(scrollbar, zone);
        this.scrollbar = scrollbar;
        this.zone = zone;
        /** Stream that emits when scroll has reached the top */
        this.reachedTop = this.reachedEvent;
    }
    ngOnInit() {
        super.ngOnInit();
    }
    /**
     * Check if scroll has reached the top (vertically)
     * @param offset Scroll offset
     * @param e Scroll event
     */
    reached(offset, e) {
        return ReachedFunctions.reachedTop(offset, e);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.1.5", ngImport: i0, type: NgScrollbarReachedTop, deps: [{ token: i1.NgScrollbar, optional: true }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "16.1.5", type: NgScrollbarReachedTop, isStandalone: true, selector: "[reachedTop], [reached-top]", outputs: { reachedTop: "reachedTop" }, usesInheritance: true, ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.1.5", ngImport: i0, type: NgScrollbarReachedTop, decorators: [{
            type: Directive,
            args: [{
                    selector: '[reachedTop], [reached-top]',
                    standalone: true,
                }]
        }], ctorParameters: function () { return [{ type: i1.NgScrollbar, decorators: [{
                    type: Optional
                }] }, { type: i0.NgZone }]; }, propDecorators: { reachedTop: [{
                type: Output
            }] } });
class NgScrollbarReachedBottom extends VerticalScrollReached {
    constructor(scrollbar, zone) {
        super(scrollbar, zone);
        this.scrollbar = scrollbar;
        this.zone = zone;
        /** Stream that emits when scroll has reached the bottom */
        this.reachedBottom = this.reachedEvent;
    }
    ngOnInit() {
        super.ngOnInit();
    }
    /**
     * Check if scroll has reached the bottom (vertically)
     * @param offset Scroll offset
     * @param e Scroll event
     */
    reached(offset, e) {
        return ReachedFunctions.reachedBottom(offset, e);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.1.5", ngImport: i0, type: NgScrollbarReachedBottom, deps: [{ token: i1.NgScrollbar, optional: true }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "16.1.5", type: NgScrollbarReachedBottom, isStandalone: true, selector: "[reachedBottom], [reached-bottom]", outputs: { reachedBottom: "reachedBottom" }, usesInheritance: true, ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.1.5", ngImport: i0, type: NgScrollbarReachedBottom, decorators: [{
            type: Directive,
            args: [{
                    selector: '[reachedBottom], [reached-bottom]',
                    standalone: true,
                }]
        }], ctorParameters: function () { return [{ type: i1.NgScrollbar, decorators: [{
                    type: Optional
                }] }, { type: i0.NgZone }]; }, propDecorators: { reachedBottom: [{
                type: Output
            }] } });
class NgScrollbarReachedStart extends HorizontalScrollReached {
    constructor(scrollbar, zone, dir) {
        super(scrollbar, zone);
        this.scrollbar = scrollbar;
        this.zone = zone;
        this.dir = dir;
        /** Stream that emits when scroll has reached the start */
        this.reachedStart = this.reachedEvent;
    }
    ngOnInit() {
        super.ngOnInit();
    }
    /**
     * Check if scroll has reached the start (horizontally)
     * @param offset Scroll offset
     * @param e Scroll event
     */
    reached(offset, e) {
        return ReachedFunctions.reachedStart(offset, e, this.dir.value, this.scrollbar.manager.rtlScrollAxisType);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.1.5", ngImport: i0, type: NgScrollbarReachedStart, deps: [{ token: i1.NgScrollbar, optional: true }, { token: i0.NgZone }, { token: i2.Directionality }], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "16.1.5", type: NgScrollbarReachedStart, isStandalone: true, selector: "[reachedStart], [reached-start]", outputs: { reachedStart: "reachedStart" }, usesInheritance: true, ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.1.5", ngImport: i0, type: NgScrollbarReachedStart, decorators: [{
            type: Directive,
            args: [{
                    selector: '[reachedStart], [reached-start]',
                    standalone: true,
                }]
        }], ctorParameters: function () { return [{ type: i1.NgScrollbar, decorators: [{
                    type: Optional
                }] }, { type: i0.NgZone }, { type: i2.Directionality }]; }, propDecorators: { reachedStart: [{
                type: Output
            }] } });
class NgScrollbarReachedEnd extends HorizontalScrollReached {
    constructor(scrollbar, zone, dir) {
        super(scrollbar, zone);
        this.scrollbar = scrollbar;
        this.zone = zone;
        this.dir = dir;
        /** Stream that emits when scroll has reached the end */
        this.reachedEnd = this.reachedEvent;
    }
    ngOnInit() {
        super.ngOnInit();
    }
    /**
     * Check if scroll has reached the end (horizontally)
     * @param offset Scroll offset
     * @param e Scroll event
     */
    reached(offset, e) {
        return ReachedFunctions.reachedEnd(offset, e, this.dir.value, this.scrollbar.manager.rtlScrollAxisType);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.1.5", ngImport: i0, type: NgScrollbarReachedEnd, deps: [{ token: i1.NgScrollbar, optional: true }, { token: i0.NgZone }, { token: i2.Directionality }], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "16.1.5", type: NgScrollbarReachedEnd, isStandalone: true, selector: "[reachedEnd], [reached-end]", outputs: { reachedEnd: "reachedEnd" }, usesInheritance: true, ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.1.5", ngImport: i0, type: NgScrollbarReachedEnd, decorators: [{
            type: Directive,
            args: [{
                    selector: '[reachedEnd], [reached-end]',
                    standalone: true,
                }]
        }], ctorParameters: function () { return [{ type: i1.NgScrollbar, decorators: [{
                    type: Optional
                }] }, { type: i0.NgZone }, { type: i2.Directionality }]; }, propDecorators: { reachedEnd: [{
                type: Output
            }] } });

class NgScrollbarReachedModule {
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.1.5", ngImport: i0, type: NgScrollbarReachedModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "16.1.5", ngImport: i0, type: NgScrollbarReachedModule, imports: [NgScrollbarReachedTop,
            NgScrollbarReachedBottom,
            NgScrollbarReachedStart,
            NgScrollbarReachedEnd], exports: [NgScrollbarReachedTop,
            NgScrollbarReachedBottom,
            NgScrollbarReachedStart,
            NgScrollbarReachedEnd] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "16.1.5", ngImport: i0, type: NgScrollbarReachedModule }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.1.5", ngImport: i0, type: NgScrollbarReachedModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        NgScrollbarReachedTop,
                        NgScrollbarReachedBottom,
                        NgScrollbarReachedStart,
                        NgScrollbarReachedEnd
                    ],
                    exports: [
                        NgScrollbarReachedTop,
                        NgScrollbarReachedBottom,
                        NgScrollbarReachedStart,
                        NgScrollbarReachedEnd
                    ]
                }]
        }] });

/**
 * Generated bundle index. Do not edit.
 */

export { NgScrollbarReachedBottom, NgScrollbarReachedEnd, NgScrollbarReachedModule, NgScrollbarReachedStart, NgScrollbarReachedTop };
//# sourceMappingURL=ngx-scrollbar-reached-event.mjs.map
