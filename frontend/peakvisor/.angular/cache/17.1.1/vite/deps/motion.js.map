{
  "version": 3,
  "sources": ["../../../../../node_modules/@motionone/utils/dist/array.es.js", "../../../../../node_modules/@motionone/utils/dist/clamp.es.js", "../../../../../node_modules/@motionone/utils/dist/defaults.es.js", "../../../../../node_modules/@motionone/utils/dist/is-number.es.js", "../../../../../node_modules/@motionone/utils/dist/is-easing-list.es.js", "../../../../../node_modules/@motionone/utils/dist/wrap.es.js", "../../../../../node_modules/@motionone/utils/dist/easing.es.js", "../../../../../node_modules/@motionone/utils/dist/mix.es.js", "../../../../../node_modules/@motionone/utils/dist/noop.es.js", "../../../../../node_modules/@motionone/utils/dist/progress.es.js", "../../../../../node_modules/@motionone/utils/dist/offset.es.js", "../../../../../node_modules/@motionone/utils/dist/interpolate.es.js", "../../../../../node_modules/@motionone/utils/dist/is-cubic-bezier.es.js", "../../../../../node_modules/@motionone/utils/dist/is-easing-generator.es.js", "../../../../../node_modules/@motionone/utils/dist/is-function.es.js", "../../../../../node_modules/@motionone/utils/dist/is-string.es.js", "../../../../../node_modules/@motionone/utils/dist/time.es.js", "../../../../../node_modules/@motionone/utils/dist/velocity.es.js", "../../../../../node_modules/@motionone/easing/dist/cubic-bezier.es.js", "../../../../../node_modules/@motionone/easing/dist/steps.es.js", "../../../../../node_modules/@motionone/animation/dist/utils/easing.es.js", "../../../../../node_modules/@motionone/animation/dist/Animation.es.js", "../../../../../node_modules/hey-listen/dist/hey-listen.es.js", "../../../../../node_modules/@motionone/types/dist/MotionValue.es.js", "../../../../../node_modules/@motionone/dom/dist/animate/data.es.js", "../../../../../node_modules/@motionone/dom/dist/animate/utils/transforms.es.js", "../../../../../node_modules/@motionone/dom/dist/animate/utils/css-var.es.js", "../../../../../node_modules/@motionone/dom/dist/animate/utils/feature-detection.es.js", "../../../../../node_modules/@motionone/dom/dist/animate/utils/easing.es.js", "../../../../../node_modules/@motionone/dom/dist/animate/utils/keyframes.es.js", "../../../../../node_modules/@motionone/dom/dist/animate/utils/get-style-name.es.js", "../../../../../node_modules/@motionone/dom/dist/animate/style.es.js", "../../../../../node_modules/@motionone/dom/dist/animate/utils/stop-animation.es.js", "../../../../../node_modules/@motionone/dom/dist/animate/utils/get-unit.es.js", "../../../../../node_modules/@motionone/dom/dist/animate/animate-style.es.js", "../../../../../node_modules/@motionone/dom/dist/animate/utils/options.es.js", "../../../../../node_modules/@motionone/dom/dist/utils/resolve-elements.es.js", "../../../../../node_modules/@motionone/dom/dist/animate/utils/controls.es.js", "../../../../../node_modules/@motionone/dom/dist/utils/stagger.es.js", "../../../../../node_modules/@motionone/dom/dist/animate/create-animate.es.js", "../../../../../node_modules/@motionone/dom/dist/animate/index.es.js", "../../../../../node_modules/@motionone/dom/dist/timeline/utils/calc-time.es.js", "../../../../../node_modules/@motionone/dom/dist/timeline/utils/edit.es.js", "../../../../../node_modules/@motionone/dom/dist/timeline/utils/sort.es.js", "../../../../../node_modules/@motionone/dom/dist/timeline/index.es.js", "../../../../../node_modules/@motionone/generators/dist/utils/velocity.es.js", "../../../../../node_modules/@motionone/generators/dist/spring/defaults.es.js", "../../../../../node_modules/@motionone/generators/dist/spring/utils.es.js", "../../../../../node_modules/@motionone/generators/dist/utils/has-reached-target.es.js", "../../../../../node_modules/@motionone/generators/dist/spring/index.es.js", "../../../../../node_modules/@motionone/generators/dist/glide/index.es.js", "../../../../../node_modules/@motionone/generators/dist/utils/pregenerate-keyframes.es.js", "../../../../../node_modules/@motionone/dom/dist/easing/create-generator-easing.es.js", "../../../../../node_modules/@motionone/dom/dist/easing/spring/index.es.js", "../../../../../node_modules/@motionone/dom/dist/easing/glide/index.es.js", "../../../../../node_modules/@motionone/dom/dist/gestures/in-view.es.js", "../../../../../node_modules/@motionone/dom/dist/gestures/resize/handle-element.es.js", "../../../../../node_modules/@motionone/dom/dist/gestures/resize/handle-window.es.js", "../../../../../node_modules/@motionone/dom/dist/gestures/resize/index.es.js", "../../../../../node_modules/@motionone/dom/dist/gestures/scroll/info.es.js", "../../../../../node_modules/@motionone/dom/dist/gestures/scroll/offsets/inset.es.js", "../../../../../node_modules/@motionone/dom/dist/gestures/scroll/offsets/presets.es.js", "../../../../../node_modules/@motionone/dom/dist/gestures/scroll/offsets/edge.es.js", "../../../../../node_modules/@motionone/dom/dist/gestures/scroll/offsets/offset.es.js", "../../../../../node_modules/@motionone/dom/dist/gestures/scroll/offsets/index.es.js", "../../../../../node_modules/@motionone/dom/dist/gestures/scroll/on-scroll-handler.es.js", "../../../../../node_modules/@motionone/dom/dist/gestures/scroll/index.es.js", "../../../../../node_modules/@motionone/dom/dist/state/utils/has-changed.es.js", "../../../../../node_modules/@motionone/dom/dist/state/utils/is-variant.es.js", "../../../../../node_modules/@motionone/dom/dist/state/utils/resolve-variant.es.js", "../../../../../node_modules/@motionone/dom/dist/state/utils/schedule.es.js", "../../../../../node_modules/@motionone/dom/dist/state/utils/events.es.js", "../../../../../node_modules/@motionone/dom/dist/state/gestures/in-view.es.js", "../../../../../node_modules/@motionone/dom/dist/state/gestures/hover.es.js", "../../../../../node_modules/@motionone/dom/dist/state/gestures/press.es.js", "../../../../../node_modules/@motionone/dom/dist/state/index.es.js", "../../../../../node_modules/@motionone/dom/dist/animate/utils/style-object.es.js", "../../../../../node_modules/@motionone/dom/dist/animate/utils/style-string.es.js", "../../../../../node_modules/motion/dist/animate.es.js"],
  "sourcesContent": ["function addUniqueItem(array, item) {\n    array.indexOf(item) === -1 && array.push(item);\n}\nfunction removeItem(arr, item) {\n    const index = arr.indexOf(item);\n    index > -1 && arr.splice(index, 1);\n}\n\nexport { addUniqueItem, removeItem };\n", "const clamp = (min, max, v) => Math.min(Math.max(v, min), max);\n\nexport { clamp };\n", "const defaults = {\n    duration: 0.3,\n    delay: 0,\n    endDelay: 0,\n    repeat: 0,\n    easing: \"ease\",\n};\n\nexport { defaults };\n", "const isNumber = (value) => typeof value === \"number\";\n\nexport { isNumber };\n", "import { isNumber } from './is-number.es.js';\n\nconst isEasingList = (easing) => Array.isArray(easing) && !isNumber(easing[0]);\n\nexport { isEasingList };\n", "const wrap = (min, max, v) => {\n    const rangeSize = max - min;\n    return ((((v - min) % rangeSize) + rangeSize) % rangeSize) + min;\n};\n\nexport { wrap };\n", "import { isEasingList } from './is-easing-list.es.js';\nimport { wrap } from './wrap.es.js';\n\nfunction getEasingForSegment(easing, i) {\n    return isEasingList(easing)\n        ? easing[wrap(0, easing.length, i)]\n        : easing;\n}\n\nexport { getEasingForSegment };\n", "const mix = (min, max, progress) => -progress * min + progress * max + min;\n\nexport { mix };\n", "const noop = () => { };\nconst noopReturn = (v) => v;\n\nexport { noop, noopReturn };\n", "const progress = (min, max, value) => max - min === 0 ? 1 : (value - min) / (max - min);\n\nexport { progress };\n", "import { mix } from './mix.es.js';\nimport { progress } from './progress.es.js';\n\nfunction fillOffset(offset, remaining) {\n    const min = offset[offset.length - 1];\n    for (let i = 1; i <= remaining; i++) {\n        const offsetProgress = progress(0, remaining, i);\n        offset.push(mix(min, 1, offsetProgress));\n    }\n}\nfunction defaultOffset(length) {\n    const offset = [0];\n    fillOffset(offset, length - 1);\n    return offset;\n}\n\nexport { defaultOffset, fillOffset };\n", "import { mix } from './mix.es.js';\nimport { noopReturn } from './noop.es.js';\nimport { fillOffset, defaultOffset } from './offset.es.js';\nimport { progress } from './progress.es.js';\nimport { getEasingForSegment } from './easing.es.js';\nimport { clamp } from './clamp.es.js';\n\nfunction interpolate(output, input = defaultOffset(output.length), easing = noopReturn) {\n    const length = output.length;\n    /**\n     * If the input length is lower than the output we\n     * fill the input to match. This currently assumes the input\n     * is an animation progress value so is a good candidate for\n     * moving outside the function.\n     */\n    const remainder = length - input.length;\n    remainder > 0 && fillOffset(input, remainder);\n    return (t) => {\n        let i = 0;\n        for (; i < length - 2; i++) {\n            if (t < input[i + 1])\n                break;\n        }\n        let progressInRange = clamp(0, 1, progress(input[i], input[i + 1], t));\n        const segmentEasing = getEasingForSegment(easing, i);\n        progressInRange = segmentEasing(progressInRange);\n        return mix(output[i], output[i + 1], progressInRange);\n    };\n}\n\nexport { interpolate };\n", "import { isNumber } from './is-number.es.js';\n\nconst isCubicBezier = (easing) => Array.isArray(easing) && isNumber(easing[0]);\n\nexport { isCubicBezier };\n", "const isEasingGenerator = (easing) => typeof easing === \"object\" &&\n    Boolean(easing.createAnimation);\n\nexport { isEasingGenerator };\n", "const isFunction = (value) => typeof value === \"function\";\n\nexport { isFunction };\n", "const isString = (value) => typeof value === \"string\";\n\nexport { isString };\n", "const time = {\n    ms: (seconds) => seconds * 1000,\n    s: (milliseconds) => milliseconds / 1000,\n};\n\nexport { time };\n", "/*\n  Convert velocity into velocity per second\n\n  @param [number]: Unit per frame\n  @param [number]: Frame duration in ms\n*/\nfunction velocityPerSecond(velocity, frameDuration) {\n    return frameDuration ? velocity * (1000 / frameDuration) : 0;\n}\n\nexport { velocityPerSecond };\n", "import { noopReturn } from '@motionone/utils';\n\n/*\n  Bezier function generator\n\n  This has been modified from GaÃ«tan Renaudeau's BezierEasing\n  https://github.com/gre/bezier-easing/blob/master/src/index.js\n  https://github.com/gre/bezier-easing/blob/master/LICENSE\n  \n  I've removed the newtonRaphsonIterate algo because in benchmarking it\n  wasn't noticiably faster than binarySubdivision, indeed removing it\n  usually improved times, depending on the curve.\n\n  I also removed the lookup table, as for the added bundle size and loop we're\n  only cutting ~4 or so subdivision iterations. I bumped the max iterations up\n  to 12 to compensate and this still tended to be faster for no perceivable\n  loss in accuracy.\n\n  Usage\n    const easeOut = cubicBezier(.17,.67,.83,.67);\n    const x = easeOut(0.5); // returns 0.627...\n*/\n// Returns x(t) given t, x1, and x2, or y(t) given t, y1, and y2.\nconst calcBezier = (t, a1, a2) => (((1.0 - 3.0 * a2 + 3.0 * a1) * t + (3.0 * a2 - 6.0 * a1)) * t + 3.0 * a1) * t;\nconst subdivisionPrecision = 0.0000001;\nconst subdivisionMaxIterations = 12;\nfunction binarySubdivide(x, lowerBound, upperBound, mX1, mX2) {\n    let currentX;\n    let currentT;\n    let i = 0;\n    do {\n        currentT = lowerBound + (upperBound - lowerBound) / 2.0;\n        currentX = calcBezier(currentT, mX1, mX2) - x;\n        if (currentX > 0.0) {\n            upperBound = currentT;\n        }\n        else {\n            lowerBound = currentT;\n        }\n    } while (Math.abs(currentX) > subdivisionPrecision &&\n        ++i < subdivisionMaxIterations);\n    return currentT;\n}\nfunction cubicBezier(mX1, mY1, mX2, mY2) {\n    // If this is a linear gradient, return linear easing\n    if (mX1 === mY1 && mX2 === mY2)\n        return noopReturn;\n    const getTForX = (aX) => binarySubdivide(aX, 0, 1, mX1, mX2);\n    // If animation is at start/end, return t without easing\n    return (t) => t === 0 || t === 1 ? t : calcBezier(getTForX(t), mY1, mY2);\n}\n\nexport { cubicBezier };\n", "import { clamp } from '@motionone/utils';\n\nconst steps = (steps, direction = \"end\") => (progress) => {\n    progress =\n        direction === \"end\"\n            ? Math.min(progress, 0.999)\n            : Math.max(progress, 0.001);\n    const expanded = progress * steps;\n    const rounded = direction === \"end\" ? Math.floor(expanded) : Math.ceil(expanded);\n    return clamp(0, 1, rounded / steps);\n};\n\nexport { steps };\n", "import { cubicBezier, steps } from '@motionone/easing';\nimport { isFunction, isCubicBezier, noopReturn } from '@motionone/utils';\n\nconst namedEasings = {\n    ease: cubicBezier(0.25, 0.1, 0.25, 1.0),\n    \"ease-in\": cubicBezier(0.42, 0.0, 1.0, 1.0),\n    \"ease-in-out\": cubicBezier(0.42, 0.0, 0.58, 1.0),\n    \"ease-out\": cubicBezier(0.0, 0.0, 0.58, 1.0),\n};\nconst functionArgsRegex = /\\((.*?)\\)/;\nfunction getEasingFunction(definition) {\n    // If already an easing function, return\n    if (isFunction(definition))\n        return definition;\n    // If an easing curve definition, return bezier function\n    if (isCubicBezier(definition))\n        return cubicBezier(...definition);\n    // If we have a predefined easing function, return\n    if (namedEasings[definition])\n        return namedEasings[definition];\n    // If this is a steps function, attempt to create easing curve\n    if (definition.startsWith(\"steps\")) {\n        const args = functionArgsRegex.exec(definition);\n        if (args) {\n            const argsArray = args[1].split(\",\");\n            return steps(parseFloat(argsArray[0]), argsArray[1].trim());\n        }\n    }\n    return noopReturn;\n}\n\nexport { getEasingFunction };\n", "import { noopReturn, defaults, isEasingGenerator, isEasingList, interpolate } from '@motionone/utils';\nimport { getEasingFunction } from './utils/easing.es.js';\n\nclass Animation {\n    constructor(output, keyframes = [0, 1], { easing, duration: initialDuration = defaults.duration, delay = defaults.delay, endDelay = defaults.endDelay, repeat = defaults.repeat, offset, direction = \"normal\", autoplay = true, } = {}) {\n        this.startTime = null;\n        this.rate = 1;\n        this.t = 0;\n        this.cancelTimestamp = null;\n        this.easing = noopReturn;\n        this.duration = 0;\n        this.totalDuration = 0;\n        this.repeat = 0;\n        this.playState = \"idle\";\n        this.finished = new Promise((resolve, reject) => {\n            this.resolve = resolve;\n            this.reject = reject;\n        });\n        easing = easing || defaults.easing;\n        if (isEasingGenerator(easing)) {\n            const custom = easing.createAnimation(keyframes);\n            easing = custom.easing;\n            keyframes = custom.keyframes || keyframes;\n            initialDuration = custom.duration || initialDuration;\n        }\n        this.repeat = repeat;\n        this.easing = isEasingList(easing) ? noopReturn : getEasingFunction(easing);\n        this.updateDuration(initialDuration);\n        const interpolate$1 = interpolate(keyframes, offset, isEasingList(easing) ? easing.map(getEasingFunction) : noopReturn);\n        this.tick = (timestamp) => {\n            var _a;\n            // TODO: Temporary fix for OptionsResolver typing\n            delay = delay;\n            let t = 0;\n            if (this.pauseTime !== undefined) {\n                t = this.pauseTime;\n            }\n            else {\n                t = (timestamp - this.startTime) * this.rate;\n            }\n            this.t = t;\n            // Convert to seconds\n            t /= 1000;\n            // Rebase on delay\n            t = Math.max(t - delay, 0);\n            /**\n             * If this animation has finished, set the current time\n             * to the total duration.\n             */\n            if (this.playState === \"finished\" && this.pauseTime === undefined) {\n                t = this.totalDuration;\n            }\n            /**\n             * Get the current progress (0-1) of the animation. If t is >\n             * than duration we'll get values like 2.5 (midway through the\n             * third iteration)\n             */\n            const progress = t / this.duration;\n            // TODO progress += iterationStart\n            /**\n             * Get the current iteration (0 indexed). For instance the floor of\n             * 2.5 is 2.\n             */\n            let currentIteration = Math.floor(progress);\n            /**\n             * Get the current progress of the iteration by taking the remainder\n             * so 2.5 is 0.5 through iteration 2\n             */\n            let iterationProgress = progress % 1.0;\n            if (!iterationProgress && progress >= 1) {\n                iterationProgress = 1;\n            }\n            /**\n             * If iteration progress is 1 we count that as the end\n             * of the previous iteration.\n             */\n            iterationProgress === 1 && currentIteration--;\n            /**\n             * Reverse progress if we're not running in \"normal\" direction\n             */\n            const iterationIsOdd = currentIteration % 2;\n            if (direction === \"reverse\" ||\n                (direction === \"alternate\" && iterationIsOdd) ||\n                (direction === \"alternate-reverse\" && !iterationIsOdd)) {\n                iterationProgress = 1 - iterationProgress;\n            }\n            const p = t >= this.totalDuration ? 1 : Math.min(iterationProgress, 1);\n            const latest = interpolate$1(this.easing(p));\n            output(latest);\n            const isAnimationFinished = this.pauseTime === undefined &&\n                (this.playState === \"finished\" || t >= this.totalDuration + endDelay);\n            if (isAnimationFinished) {\n                this.playState = \"finished\";\n                (_a = this.resolve) === null || _a === void 0 ? void 0 : _a.call(this, latest);\n            }\n            else if (this.playState !== \"idle\") {\n                this.frameRequestId = requestAnimationFrame(this.tick);\n            }\n        };\n        if (autoplay)\n            this.play();\n    }\n    play() {\n        const now = performance.now();\n        this.playState = \"running\";\n        if (this.pauseTime !== undefined) {\n            this.startTime = now - this.pauseTime;\n        }\n        else if (!this.startTime) {\n            this.startTime = now;\n        }\n        this.cancelTimestamp = this.startTime;\n        this.pauseTime = undefined;\n        this.frameRequestId = requestAnimationFrame(this.tick);\n    }\n    pause() {\n        this.playState = \"paused\";\n        this.pauseTime = this.t;\n    }\n    finish() {\n        this.playState = \"finished\";\n        this.tick(0);\n    }\n    stop() {\n        var _a;\n        this.playState = \"idle\";\n        if (this.frameRequestId !== undefined) {\n            cancelAnimationFrame(this.frameRequestId);\n        }\n        (_a = this.reject) === null || _a === void 0 ? void 0 : _a.call(this, false);\n    }\n    cancel() {\n        this.stop();\n        this.tick(this.cancelTimestamp);\n    }\n    reverse() {\n        this.rate *= -1;\n    }\n    commitStyles() { }\n    updateDuration(duration) {\n        this.duration = duration;\n        this.totalDuration = duration * (this.repeat + 1);\n    }\n    get currentTime() {\n        return this.t;\n    }\n    set currentTime(t) {\n        if (this.pauseTime !== undefined || this.rate === 0) {\n            this.pauseTime = t;\n        }\n        else {\n            this.startTime = performance.now() - t / this.rate;\n        }\n    }\n    get playbackRate() {\n        return this.rate;\n    }\n    set playbackRate(rate) {\n        this.rate = rate;\n    }\n}\n\nexport { Animation };\n", "var warning = function () { };\r\nvar invariant = function () { };\r\nif (process.env.NODE_ENV !== 'production') {\r\n    warning = function (check, message) {\r\n        if (!check && typeof console !== 'undefined') {\r\n            console.warn(message);\r\n        }\r\n    };\r\n    invariant = function (check, message) {\r\n        if (!check) {\r\n            throw new Error(message);\r\n        }\r\n    };\r\n}\n\nexport { invariant, warning };\n", "/**\n * The MotionValue tracks the state of a single animatable\n * value. Currently, updatedAt and current are unused. The\n * long term idea is to use this to minimise the number\n * of DOM reads, and to abstract the DOM interactions here.\n */\nclass MotionValue {\n    setAnimation(animation) {\n        this.animation = animation;\n        animation === null || animation === void 0 ? void 0 : animation.finished.then(() => this.clearAnimation()).catch(() => { });\n    }\n    clearAnimation() {\n        this.animation = this.generator = undefined;\n    }\n}\n\nexport { MotionValue };\n", "import { MotionValue } from '@motionone/types';\n\nconst data = new WeakMap();\nfunction getAnimationData(element) {\n    if (!data.has(element)) {\n        data.set(element, {\n            transforms: [],\n            values: new Map(),\n        });\n    }\n    return data.get(element);\n}\nfunction getMotionValue(motionValues, name) {\n    if (!motionValues.has(name)) {\n        motionValues.set(name, new MotionValue());\n    }\n    return motionValues.get(name);\n}\n\nexport { getAnimationData, getMotionValue };\n", "import { noopReturn, addUniqueItem } from '@motionone/utils';\nimport { getAnimationData } from '../data.es.js';\n\n/**\n * A list of all transformable axes. We'll use this list to generated a version\n * of each axes for each transform.\n */\nconst axes = [\"\", \"X\", \"Y\", \"Z\"];\n/**\n * An ordered array of each transformable value. By default, transform values\n * will be sorted to this order.\n */\nconst order = [\"translate\", \"scale\", \"rotate\", \"skew\"];\nconst transformAlias = {\n    x: \"translateX\",\n    y: \"translateY\",\n    z: \"translateZ\",\n};\nconst rotation = {\n    syntax: \"<angle>\",\n    initialValue: \"0deg\",\n    toDefaultUnit: (v) => v + \"deg\",\n};\nconst baseTransformProperties = {\n    translate: {\n        syntax: \"<length-percentage>\",\n        initialValue: \"0px\",\n        toDefaultUnit: (v) => v + \"px\",\n    },\n    rotate: rotation,\n    scale: {\n        syntax: \"<number>\",\n        initialValue: 1,\n        toDefaultUnit: noopReturn,\n    },\n    skew: rotation,\n};\nconst transformDefinitions = new Map();\nconst asTransformCssVar = (name) => `--motion-${name}`;\n/**\n * Generate a list of every possible transform key\n */\nconst transforms = [\"x\", \"y\", \"z\"];\norder.forEach((name) => {\n    axes.forEach((axis) => {\n        transforms.push(name + axis);\n        transformDefinitions.set(asTransformCssVar(name + axis), baseTransformProperties[name]);\n    });\n});\n/**\n * A function to use with Array.sort to sort transform keys by their default order.\n */\nconst compareTransformOrder = (a, b) => transforms.indexOf(a) - transforms.indexOf(b);\n/**\n * Provide a quick way to check if a string is the name of a transform\n */\nconst transformLookup = new Set(transforms);\nconst isTransform = (name) => transformLookup.has(name);\nconst addTransformToElement = (element, name) => {\n    // Map x to translateX etc\n    if (transformAlias[name])\n        name = transformAlias[name];\n    const { transforms } = getAnimationData(element);\n    addUniqueItem(transforms, name);\n    /**\n     * TODO: An optimisation here could be to cache the transform in element data\n     * and only update if this has changed.\n     */\n    element.style.transform = buildTransformTemplate(transforms);\n};\nconst buildTransformTemplate = (transforms) => transforms\n    .sort(compareTransformOrder)\n    .reduce(transformListToString, \"\")\n    .trim();\nconst transformListToString = (template, name) => `${template} ${name}(var(${asTransformCssVar(name)}))`;\n\nexport { addTransformToElement, asTransformCssVar, axes, buildTransformTemplate, compareTransformOrder, isTransform, transformAlias, transformDefinitions };\n", "import { transformDefinitions } from './transforms.es.js';\n\nconst isCssVar = (name) => name.startsWith(\"--\");\nconst registeredProperties = new Set();\nfunction registerCssVariable(name) {\n    if (registeredProperties.has(name))\n        return;\n    registeredProperties.add(name);\n    try {\n        const { syntax, initialValue } = transformDefinitions.has(name)\n            ? transformDefinitions.get(name)\n            : {};\n        CSS.registerProperty({\n            name,\n            inherits: false,\n            syntax,\n            initialValue,\n        });\n    }\n    catch (e) { }\n}\n\nexport { isCssVar, registerCssVariable, registeredProperties };\n", "const testAnimation = (keyframes, options) => document.createElement(\"div\").animate(keyframes, options);\nconst featureTests = {\n    cssRegisterProperty: () => typeof CSS !== \"undefined\" &&\n        Object.hasOwnProperty.call(CSS, \"registerProperty\"),\n    waapi: () => Object.hasOwnProperty.call(Element.prototype, \"animate\"),\n    partialKeyframes: () => {\n        try {\n            testAnimation({ opacity: [1] });\n        }\n        catch (e) {\n            return false;\n        }\n        return true;\n    },\n    finished: () => Boolean(testAnimation({ opacity: [0, 1] }, { duration: 0.001 }).finished),\n    linearEasing: () => {\n        try {\n            testAnimation({ opacity: 0 }, { easing: \"linear(0, 1)\" });\n        }\n        catch (e) {\n            return false;\n        }\n        return true;\n    },\n};\nconst results = {};\nconst supports = {};\nfor (const key in featureTests) {\n    supports[key] = () => {\n        if (results[key] === undefined)\n            results[key] = featureTests[key]();\n        return results[key];\n    };\n}\n\nexport { supports };\n", "import { isFunction, defaults, isCubicBezier, progress } from '@motionone/utils';\nimport { supports } from './feature-detection.es.js';\n\n// Create a linear easing point for every x second\nconst resolution = 0.015;\nconst generateLinearEasingPoints = (easing, duration) => {\n    let points = \"\";\n    const numPoints = Math.round(duration / resolution);\n    for (let i = 0; i < numPoints; i++) {\n        points += easing(progress(0, numPoints - 1, i)) + \", \";\n    }\n    return points.substring(0, points.length - 2);\n};\nconst convertEasing = (easing, duration) => {\n    if (isFunction(easing)) {\n        return supports.linearEasing()\n            ? `linear(${generateLinearEasingPoints(easing, duration)})`\n            : defaults.easing;\n    }\n    else {\n        return isCubicBezier(easing) ? cubicBezierAsString(easing) : easing;\n    }\n};\nconst cubicBezierAsString = ([a, b, c, d]) => `cubic-bezier(${a}, ${b}, ${c}, ${d})`;\n\nexport { convertEasing, cubicBezierAsString, generateLinearEasingPoints };\n", "function hydrateKeyframes(keyframes, readInitialValue) {\n    for (let i = 0; i < keyframes.length; i++) {\n        if (keyframes[i] === null) {\n            keyframes[i] = i ? keyframes[i - 1] : readInitialValue();\n        }\n    }\n    return keyframes;\n}\nconst keyframesList = (keyframes) => Array.isArray(keyframes) ? keyframes : [keyframes];\n\nexport { hydrateKeyframes, keyframesList };\n", "import { isTransform, asTransformCssVar, transformAlias } from './transforms.es.js';\n\nfunction getStyleName(key) {\n    if (transformAlias[key])\n        key = transformAlias[key];\n    return isTransform(key) ? asTransformCssVar(key) : key;\n}\n\nexport { getStyleName };\n", "import { isCssVar } from './utils/css-var.es.js';\nimport { getStyleName } from './utils/get-style-name.es.js';\nimport { transformDefinitions } from './utils/transforms.es.js';\n\nconst style = {\n    get: (element, name) => {\n        name = getStyleName(name);\n        let value = isCssVar(name)\n            ? element.style.getPropertyValue(name)\n            : getComputedStyle(element)[name];\n        if (!value && value !== 0) {\n            const definition = transformDefinitions.get(name);\n            if (definition)\n                value = definition.initialValue;\n        }\n        return value;\n    },\n    set: (element, name, value) => {\n        name = getStyleName(name);\n        if (isCssVar(name)) {\n            element.style.setProperty(name, value);\n        }\n        else {\n            element.style[name] = value;\n        }\n    },\n};\n\nexport { style };\n", "function stopAnimation(animation, needsCommit = true) {\n    if (!animation || animation.playState === \"finished\")\n        return;\n    // Suppress error thrown by WAAPI\n    try {\n        if (animation.stop) {\n            animation.stop();\n        }\n        else {\n            needsCommit && animation.commitStyles();\n            animation.cancel();\n        }\n    }\n    catch (e) { }\n}\n\nexport { stopAnimation };\n", "import { noopReturn, isString } from '@motionone/utils';\n\nfunction getUnitConverter(keyframes, definition) {\n    var _a;\n    let toUnit = (definition === null || definition === void 0 ? void 0 : definition.toDefaultUnit) || noopReturn;\n    const finalKeyframe = keyframes[keyframes.length - 1];\n    if (isString(finalKeyframe)) {\n        const unit = ((_a = finalKeyframe.match(/(-?[\\d.]+)([a-z%]*)/)) === null || _a === void 0 ? void 0 : _a[2]) || \"\";\n        if (unit)\n            toUnit = (value) => value + unit;\n    }\n    return toUnit;\n}\n\nexport { getUnitConverter };\n", "import { getAnimationData, getMotionValue } from './data.es.js';\nimport { isCssVar, registerCssVariable } from './utils/css-var.es.js';\nimport { defaults, isEasingGenerator, isFunction, isEasingList, isNumber, time, noop } from '@motionone/utils';\nimport { isTransform, addTransformToElement, transformDefinitions } from './utils/transforms.es.js';\nimport { convertEasing } from './utils/easing.es.js';\nimport { supports } from './utils/feature-detection.es.js';\nimport { hydrateKeyframes, keyframesList } from './utils/keyframes.es.js';\nimport { style } from './style.es.js';\nimport { getStyleName } from './utils/get-style-name.es.js';\nimport { stopAnimation } from './utils/stop-animation.es.js';\nimport { getUnitConverter } from './utils/get-unit.es.js';\n\nfunction getDevToolsRecord() {\n    return window.__MOTION_DEV_TOOLS_RECORD;\n}\nfunction animateStyle(element, key, keyframesDefinition, options = {}, AnimationPolyfill) {\n    const record = getDevToolsRecord();\n    const isRecording = options.record !== false && record;\n    let animation;\n    let { duration = defaults.duration, delay = defaults.delay, endDelay = defaults.endDelay, repeat = defaults.repeat, easing = defaults.easing, persist = false, direction, offset, allowWebkitAcceleration = false, autoplay = true, } = options;\n    const data = getAnimationData(element);\n    const valueIsTransform = isTransform(key);\n    let canAnimateNatively = supports.waapi();\n    /**\n     * If this is an individual transform, we need to map its\n     * key to a CSS variable and update the element's transform style\n     */\n    valueIsTransform && addTransformToElement(element, key);\n    const name = getStyleName(key);\n    const motionValue = getMotionValue(data.values, name);\n    /**\n     * Get definition of value, this will be used to convert numerical\n     * keyframes into the default value type.\n     */\n    const definition = transformDefinitions.get(name);\n    /**\n     * Stop the current animation, if any. Because this will trigger\n     * commitStyles (DOM writes) and we might later trigger DOM reads,\n     * this is fired now and we return a factory function to create\n     * the actual animation that can get called in batch,\n     */\n    stopAnimation(motionValue.animation, !(isEasingGenerator(easing) && motionValue.generator) &&\n        options.record !== false);\n    /**\n     * Batchable factory function containing all DOM reads.\n     */\n    return () => {\n        const readInitialValue = () => { var _a, _b; return (_b = (_a = style.get(element, name)) !== null && _a !== void 0 ? _a : definition === null || definition === void 0 ? void 0 : definition.initialValue) !== null && _b !== void 0 ? _b : 0; };\n        /**\n         * Replace null values with the previous keyframe value, or read\n         * it from the DOM if it's the first keyframe.\n         */\n        let keyframes = hydrateKeyframes(keyframesList(keyframesDefinition), readInitialValue);\n        /**\n         * Detect unit type of keyframes.\n         */\n        const toUnit = getUnitConverter(keyframes, definition);\n        if (isEasingGenerator(easing)) {\n            const custom = easing.createAnimation(keyframes, key !== \"opacity\", readInitialValue, name, motionValue);\n            easing = custom.easing;\n            keyframes = custom.keyframes || keyframes;\n            duration = custom.duration || duration;\n        }\n        /**\n         * If this is a CSS variable we need to register it with the browser\n         * before it can be animated natively. We also set it with setProperty\n         * rather than directly onto the element.style object.\n         */\n        if (isCssVar(name)) {\n            if (supports.cssRegisterProperty()) {\n                registerCssVariable(name);\n            }\n            else {\n                canAnimateNatively = false;\n            }\n        }\n        /**\n         * If we've been passed a custom easing function, and this browser\n         * does **not** support linear() easing, and the value is a transform\n         * (and thus a pure number) we can still support the custom easing\n         * by falling back to the animation polyfill.\n         */\n        if (valueIsTransform &&\n            !supports.linearEasing() &&\n            (isFunction(easing) || (isEasingList(easing) && easing.some(isFunction)))) {\n            canAnimateNatively = false;\n        }\n        /**\n         * If we can animate this value with WAAPI, do so.\n         */\n        if (canAnimateNatively) {\n            /**\n             * Convert numbers to default value types. Currently this only supports\n             * transforms but it could also support other value types.\n             */\n            if (definition) {\n                keyframes = keyframes.map((value) => isNumber(value) ? definition.toDefaultUnit(value) : value);\n            }\n            /**\n             * If this browser doesn't support partial/implicit keyframes we need to\n             * explicitly provide one.\n             */\n            if (keyframes.length === 1 &&\n                (!supports.partialKeyframes() || isRecording)) {\n                keyframes.unshift(readInitialValue());\n            }\n            const animationOptions = {\n                delay: time.ms(delay),\n                duration: time.ms(duration),\n                endDelay: time.ms(endDelay),\n                easing: !isEasingList(easing)\n                    ? convertEasing(easing, duration)\n                    : undefined,\n                direction,\n                iterations: repeat + 1,\n                fill: \"both\",\n            };\n            animation = element.animate({\n                [name]: keyframes,\n                offset,\n                easing: isEasingList(easing)\n                    ? easing.map((thisEasing) => convertEasing(thisEasing, duration))\n                    : undefined,\n            }, animationOptions);\n            /**\n             * Polyfill finished Promise in browsers that don't support it\n             */\n            if (!animation.finished) {\n                animation.finished = new Promise((resolve, reject) => {\n                    animation.onfinish = resolve;\n                    animation.oncancel = reject;\n                });\n            }\n            const target = keyframes[keyframes.length - 1];\n            animation.finished\n                .then(() => {\n                if (persist)\n                    return;\n                // Apply styles to target\n                style.set(element, name, target);\n                // Ensure fill modes don't persist\n                animation.cancel();\n            })\n                .catch(noop);\n            /**\n             * This forces Webkit to run animations on the main thread by exploiting\n             * this condition:\n             * https://trac.webkit.org/browser/webkit/trunk/Source/WebCore/platform/graphics/ca/GraphicsLayerCA.cpp?rev=281238#L1099\n             *\n             * This fixes Webkit's timing bugs, like accelerated animations falling\n             * out of sync with main thread animations and massive delays in starting\n             * accelerated animations in WKWebView.\n             */\n            if (!allowWebkitAcceleration)\n                animation.playbackRate = 1.000001;\n            /**\n             * If we can't animate the value natively then we can fallback to the numbers-only\n             * polyfill for transforms.\n             */\n        }\n        else if (AnimationPolyfill && valueIsTransform) {\n            /**\n             * If any keyframe is a string (because we measured it from the DOM), we need to convert\n             * it into a number before passing to the Animation polyfill.\n             */\n            keyframes = keyframes.map((value) => typeof value === \"string\" ? parseFloat(value) : value);\n            /**\n             * If we only have a single keyframe, we need to create an initial keyframe by reading\n             * the current value from the DOM.\n             */\n            if (keyframes.length === 1) {\n                keyframes.unshift(parseFloat(readInitialValue()));\n            }\n            animation = new AnimationPolyfill((latest) => {\n                style.set(element, name, toUnit ? toUnit(latest) : latest);\n            }, keyframes, Object.assign(Object.assign({}, options), { duration,\n                easing }));\n        }\n        else {\n            const target = keyframes[keyframes.length - 1];\n            style.set(element, name, definition && isNumber(target)\n                ? definition.toDefaultUnit(target)\n                : target);\n        }\n        if (isRecording) {\n            record(element, key, keyframes, {\n                duration,\n                delay: delay,\n                easing,\n                repeat,\n                offset,\n            }, \"motion-one\");\n        }\n        motionValue.setAnimation(animation);\n        if (animation && !autoplay)\n            animation.pause();\n        return animation;\n    };\n}\n\nexport { animateStyle };\n", "const getOptions = (options, key) => \n/**\n * TODO: Make test for this\n * Always return a new object otherwise delay is overwritten by results of stagger\n * and this results in no stagger\n */\noptions[key] ? Object.assign(Object.assign({}, options), options[key]) : Object.assign({}, options);\n\nexport { getOptions };\n", "function resolveElements(elements, selectorCache) {\n    var _a;\n    if (typeof elements === \"string\") {\n        if (selectorCache) {\n            (_a = selectorCache[elements]) !== null && _a !== void 0 ? _a : (selectorCache[elements] = document.querySelectorAll(elements));\n            elements = selectorCache[elements];\n        }\n        else {\n            elements = document.querySelectorAll(elements);\n        }\n    }\n    else if (elements instanceof Element) {\n        elements = [elements];\n    }\n    /**\n     * Return an empty array\n     */\n    return Array.from(elements || []);\n}\n\nexport { resolveElements };\n", "import { defaults, noop, time } from '@motionone/utils';\nimport { stopAnimation } from './stop-animation.es.js';\n\nconst createAnimation = (factory) => factory();\nconst withControls = (animationFactory, options, duration = defaults.duration) => {\n    return new Proxy({\n        animations: animationFactory.map(createAnimation).filter(Boolean),\n        duration,\n        options,\n    }, controls);\n};\n/**\n * TODO:\n * Currently this returns the first animation, ideally it would return\n * the first active animation.\n */\nconst getActiveAnimation = (state) => state.animations[0];\nconst controls = {\n    get: (target, key) => {\n        const activeAnimation = getActiveAnimation(target);\n        switch (key) {\n            case \"duration\":\n                return target.duration;\n            case \"currentTime\":\n                return time.s((activeAnimation === null || activeAnimation === void 0 ? void 0 : activeAnimation[key]) || 0);\n            case \"playbackRate\":\n            case \"playState\":\n                return activeAnimation === null || activeAnimation === void 0 ? void 0 : activeAnimation[key];\n            case \"finished\":\n                if (!target.finished) {\n                    target.finished = Promise.all(target.animations.map(selectFinished)).catch(noop);\n                }\n                return target.finished;\n            case \"stop\":\n                return () => {\n                    target.animations.forEach((animation) => stopAnimation(animation));\n                };\n            case \"forEachNative\":\n                /**\n                 * This is for internal use only, fire a callback for each\n                 * underlying animation.\n                 */\n                return (callback) => {\n                    target.animations.forEach((animation) => callback(animation, target));\n                };\n            default:\n                return typeof (activeAnimation === null || activeAnimation === void 0 ? void 0 : activeAnimation[key]) === \"undefined\"\n                    ? undefined\n                    : () => target.animations.forEach((animation) => animation[key]());\n        }\n    },\n    set: (target, key, value) => {\n        switch (key) {\n            case \"currentTime\":\n                value = time.ms(value);\n            // Fall-through\n            case \"playbackRate\":\n                for (let i = 0; i < target.animations.length; i++) {\n                    target.animations[i][key] = value;\n                }\n                return true;\n        }\n        return false;\n    },\n};\nconst selectFinished = (animation) => animation.finished;\n\nexport { controls, withControls };\n", "import { isNumber, isFunction } from '@motionone/utils';\nimport { getEasingFunction } from '@motionone/animation';\n\nfunction stagger(duration = 0.1, { start = 0, from = 0, easing } = {}) {\n    return (i, total) => {\n        const fromIndex = isNumber(from) ? from : getFromIndex(from, total);\n        const distance = Math.abs(fromIndex - i);\n        let delay = duration * distance;\n        if (easing) {\n            const maxDelay = total * duration;\n            const easingFunction = getEasingFunction(easing);\n            delay = easingFunction(delay / maxDelay) * maxDelay;\n        }\n        return start + delay;\n    };\n}\nfunction getFromIndex(from, total) {\n    if (from === \"first\") {\n        return 0;\n    }\n    else {\n        const lastIndex = total - 1;\n        return from === \"last\" ? lastIndex : lastIndex / 2;\n    }\n}\nfunction resolveOption(option, i, total) {\n    return isFunction(option) ? option(i, total) : option;\n}\n\nexport { getFromIndex, resolveOption, stagger };\n", "import { invariant } from 'hey-listen';\nimport { animateStyle } from './animate-style.es.js';\nimport { getOptions } from './utils/options.es.js';\nimport { resolveElements } from '../utils/resolve-elements.es.js';\nimport { withControls } from './utils/controls.es.js';\nimport { resolveOption } from '../utils/stagger.es.js';\n\nfunction createAnimate(AnimatePolyfill) {\n    return function animate(elements, keyframes, options = {}) {\n        elements = resolveElements(elements);\n        const numElements = elements.length;\n        invariant(Boolean(numElements), \"No valid element provided.\");\n        invariant(Boolean(keyframes), \"No keyframes defined.\");\n        /**\n         * Create and start new animations\n         */\n        const animationFactories = [];\n        for (let i = 0; i < numElements; i++) {\n            const element = elements[i];\n            for (const key in keyframes) {\n                const valueOptions = getOptions(options, key);\n                valueOptions.delay = resolveOption(valueOptions.delay, i, numElements);\n                const animation = animateStyle(element, key, keyframes[key], valueOptions, AnimatePolyfill);\n                animationFactories.push(animation);\n            }\n        }\n        return withControls(animationFactories, options, \n        /**\n         * TODO:\n         * If easing is set to spring or glide, duration will be dynamically\n         * generated. Ideally we would dynamically generate this from\n         * animation.effect.getComputedTiming().duration but this isn't\n         * supported in iOS13 or our number polyfill. Perhaps it's possible\n         * to Proxy animations returned from animateStyle that has duration\n         * as a getter.\n         */\n        options.duration);\n    };\n}\n\nexport { createAnimate };\n", "import { Animation } from '@motionone/animation';\nimport { createAnimate } from './create-animate.es.js';\n\nconst animate = createAnimate(Animation);\n\nexport { animate };\n", "import { isNumber } from '@motionone/utils';\n\nfunction calcNextTime(current, next, prev, labels) {\n    var _a;\n    if (isNumber(next)) {\n        return next;\n    }\n    else if (next.startsWith(\"-\") || next.startsWith(\"+\")) {\n        return Math.max(0, current + parseFloat(next));\n    }\n    else if (next === \"<\") {\n        return prev;\n    }\n    else {\n        return (_a = labels.get(next)) !== null && _a !== void 0 ? _a : current;\n    }\n}\n\nexport { calcNextTime };\n", "import { mix, getEasingForSegment, removeItem } from '@motionone/utils';\n\nfunction eraseKeyframes(sequence, startTime, endTime) {\n    for (let i = 0; i < sequence.length; i++) {\n        const keyframe = sequence[i];\n        if (keyframe.at > startTime && keyframe.at < endTime) {\n            removeItem(sequence, keyframe);\n            // If we remove this item we have to push the pointer back one\n            i--;\n        }\n    }\n}\nfunction addKeyframes(sequence, keyframes, easing, offset, startTime, endTime) {\n    /**\n     * Erase every existing value between currentTime and targetTime,\n     * this will essentially splice this timeline into any currently\n     * defined ones.\n     */\n    eraseKeyframes(sequence, startTime, endTime);\n    for (let i = 0; i < keyframes.length; i++) {\n        sequence.push({\n            value: keyframes[i],\n            at: mix(startTime, endTime, offset[i]),\n            easing: getEasingForSegment(easing, i),\n        });\n    }\n}\n\nexport { addKeyframes, eraseKeyframes };\n", "function compareByTime(a, b) {\n    if (a.at === b.at) {\n        return a.value === null ? 1 : -1;\n    }\n    else {\n        return a.at - b.at;\n    }\n}\n\nexport { compareByTime };\n", "import { __rest } from 'tslib';\nimport { invariant } from 'hey-listen';\nimport { isString, defaults, isEasingGenerator, defaultOffset, fillOffset, progress } from '@motionone/utils';\nimport { resolveOption } from '../utils/stagger.es.js';\nimport { animateStyle } from '../animate/animate-style.es.js';\nimport { withControls } from '../animate/utils/controls.es.js';\nimport { keyframesList } from '../animate/utils/keyframes.es.js';\nimport { getOptions } from '../animate/utils/options.es.js';\nimport { resolveElements } from '../utils/resolve-elements.es.js';\nimport { calcNextTime } from './utils/calc-time.es.js';\nimport { addKeyframes } from './utils/edit.es.js';\nimport { compareByTime } from './utils/sort.es.js';\nimport { Animation } from '@motionone/animation';\n\nfunction timeline(definition, options = {}) {\n    var _a;\n    const animationDefinitions = createAnimationsFromTimeline(definition, options);\n    /**\n     * Create and start animations\n     */\n    const animationFactories = animationDefinitions\n        .map((definition) => animateStyle(...definition, Animation))\n        .filter(Boolean);\n    return withControls(animationFactories, options, \n    // Get the duration from the first animation definition\n    (_a = animationDefinitions[0]) === null || _a === void 0 ? void 0 : _a[3].duration);\n}\nfunction createAnimationsFromTimeline(definition, _a = {}) {\n    var { defaultOptions = {} } = _a, timelineOptions = __rest(_a, [\"defaultOptions\"]);\n    const animationDefinitions = [];\n    const elementSequences = new Map();\n    const elementCache = {};\n    const timeLabels = new Map();\n    let prevTime = 0;\n    let currentTime = 0;\n    let totalDuration = 0;\n    /**\n     * Build the timeline by mapping over the definition array and converting\n     * the definitions into keyframes and offsets with absolute time values.\n     * These will later get converted into relative offsets in a second pass.\n     */\n    for (let i = 0; i < definition.length; i++) {\n        const segment = definition[i];\n        /**\n         * If this is a timeline label, mark it and skip the rest of this iteration.\n         */\n        if (isString(segment)) {\n            timeLabels.set(segment, currentTime);\n            continue;\n        }\n        else if (!Array.isArray(segment)) {\n            timeLabels.set(segment.name, calcNextTime(currentTime, segment.at, prevTime, timeLabels));\n            continue;\n        }\n        const [elementDefinition, keyframes, options = {}] = segment;\n        /**\n         * If a relative or absolute time value has been specified we need to resolve\n         * it in relation to the currentTime.\n         */\n        if (options.at !== undefined) {\n            currentTime = calcNextTime(currentTime, options.at, prevTime, timeLabels);\n        }\n        /**\n         * Keep track of the maximum duration in this definition. This will be\n         * applied to currentTime once the definition has been parsed.\n         */\n        let maxDuration = 0;\n        /**\n         * Find all the elements specified in the definition and parse value\n         * keyframes from their timeline definitions.\n         */\n        const elements = resolveElements(elementDefinition, elementCache);\n        const numElements = elements.length;\n        for (let elementIndex = 0; elementIndex < numElements; elementIndex++) {\n            const element = elements[elementIndex];\n            const elementSequence = getElementSequence(element, elementSequences);\n            for (const key in keyframes) {\n                const valueSequence = getValueSequence(key, elementSequence);\n                let valueKeyframes = keyframesList(keyframes[key]);\n                const valueOptions = getOptions(options, key);\n                let { duration = defaultOptions.duration || defaults.duration, easing = defaultOptions.easing || defaults.easing, } = valueOptions;\n                if (isEasingGenerator(easing)) {\n                    invariant(key === \"opacity\" || valueKeyframes.length > 1, \"spring must be provided 2 keyframes within timeline()\");\n                    const custom = easing.createAnimation(valueKeyframes, key !== \"opacity\", () => 0, key);\n                    easing = custom.easing;\n                    valueKeyframes = custom.keyframes || valueKeyframes;\n                    duration = custom.duration || duration;\n                }\n                const delay = resolveOption(options.delay, elementIndex, numElements) || 0;\n                const startTime = currentTime + delay;\n                const targetTime = startTime + duration;\n                /**\n                 *\n                 */\n                let { offset = defaultOffset(valueKeyframes.length) } = valueOptions;\n                /**\n                 * If there's only one offset of 0, fill in a second with length 1\n                 *\n                 * TODO: Ensure there's a test that covers this removal\n                 */\n                if (offset.length === 1 && offset[0] === 0) {\n                    offset[1] = 1;\n                }\n                /**\n                 * Fill out if offset if fewer offsets than keyframes\n                 */\n                const remainder = offset.length - valueKeyframes.length;\n                remainder > 0 && fillOffset(offset, remainder);\n                /**\n                 * If only one value has been set, ie [1], push a null to the start of\n                 * the keyframe array. This will let us mark a keyframe at this point\n                 * that will later be hydrated with the previous value.\n                 */\n                valueKeyframes.length === 1 && valueKeyframes.unshift(null);\n                /**\n                 * Add keyframes, mapping offsets to absolute time.\n                 */\n                addKeyframes(valueSequence, valueKeyframes, easing, offset, startTime, targetTime);\n                maxDuration = Math.max(delay + duration, maxDuration);\n                totalDuration = Math.max(targetTime, totalDuration);\n            }\n        }\n        prevTime = currentTime;\n        currentTime += maxDuration;\n    }\n    /**\n     * For every element and value combination create a new animation.\n     */\n    elementSequences.forEach((valueSequences, element) => {\n        for (const key in valueSequences) {\n            const valueSequence = valueSequences[key];\n            /**\n             * Arrange all the keyframes in ascending time order.\n             */\n            valueSequence.sort(compareByTime);\n            const keyframes = [];\n            const valueOffset = [];\n            const valueEasing = [];\n            /**\n             * For each keyframe, translate absolute times into\n             * relative offsets based on the total duration of the timeline.\n             */\n            for (let i = 0; i < valueSequence.length; i++) {\n                const { at, value, easing } = valueSequence[i];\n                keyframes.push(value);\n                valueOffset.push(progress(0, totalDuration, at));\n                valueEasing.push(easing || defaults.easing);\n            }\n            /**\n             * If the first keyframe doesn't land on offset: 0\n             * provide one by duplicating the initial keyframe. This ensures\n             * it snaps to the first keyframe when the animation starts.\n             */\n            if (valueOffset[0] !== 0) {\n                valueOffset.unshift(0);\n                keyframes.unshift(keyframes[0]);\n                valueEasing.unshift(\"linear\");\n            }\n            /**\n             * If the last keyframe doesn't land on offset: 1\n             * provide one with a null wildcard value. This will ensure it\n             * stays static until the end of the animation.\n             */\n            if (valueOffset[valueOffset.length - 1] !== 1) {\n                valueOffset.push(1);\n                keyframes.push(null);\n            }\n            animationDefinitions.push([\n                element,\n                key,\n                keyframes,\n                Object.assign(Object.assign(Object.assign({}, defaultOptions), { duration: totalDuration, easing: valueEasing, offset: valueOffset }), timelineOptions),\n            ]);\n        }\n    });\n    return animationDefinitions;\n}\nfunction getElementSequence(element, sequences) {\n    !sequences.has(element) && sequences.set(element, {});\n    return sequences.get(element);\n}\nfunction getValueSequence(name, sequences) {\n    if (!sequences[name])\n        sequences[name] = [];\n    return sequences[name];\n}\n\nexport { createAnimationsFromTimeline, timeline };\n", "import { velocityPerSecond } from '@motionone/utils';\n\nconst sampleT = 5; // ms\nfunction calcGeneratorVelocity(resolveValue, t, current) {\n    const prevT = Math.max(t - sampleT, 0);\n    return velocityPerSecond(current - resolveValue(prevT), t - prevT);\n}\n\nexport { calcGeneratorVelocity };\n", "const defaults = {\n    stiffness: 100.0,\n    damping: 10.0,\n    mass: 1.0,\n};\n\nexport { defaults };\n", "import { defaults } from './defaults.es.js';\n\nconst calcDampingRatio = (stiffness = defaults.stiffness, damping = defaults.damping, mass = defaults.mass) => damping / (2 * Math.sqrt(stiffness * mass));\n\nexport { calcDampingRatio };\n", "function hasReachedTarget(origin, target, current) {\n    return ((origin < target && current >= target) ||\n        (origin > target && current <= target));\n}\n\nexport { hasReachedTarget };\n", "import { time } from '@motionone/utils';\nimport { defaults } from './defaults.es.js';\nimport { calcDampingRatio } from './utils.es.js';\nimport { hasReachedTarget } from '../utils/has-reached-target.es.js';\nimport { calcGeneratorVelocity } from '../utils/velocity.es.js';\n\nconst spring = ({ stiffness = defaults.stiffness, damping = defaults.damping, mass = defaults.mass, from = 0, to = 1, velocity = 0.0, restSpeed, restDistance, } = {}) => {\n    velocity = velocity ? time.s(velocity) : 0.0;\n    const state = {\n        done: false,\n        hasReachedTarget: false,\n        current: from,\n        target: to,\n    };\n    const initialDelta = to - from;\n    const undampedAngularFreq = Math.sqrt(stiffness / mass) / 1000;\n    const dampingRatio = calcDampingRatio(stiffness, damping, mass);\n    const isGranularScale = Math.abs(initialDelta) < 5;\n    restSpeed || (restSpeed = isGranularScale ? 0.01 : 2);\n    restDistance || (restDistance = isGranularScale ? 0.005 : 0.5);\n    let resolveSpring;\n    if (dampingRatio < 1) {\n        const angularFreq = undampedAngularFreq * Math.sqrt(1 - dampingRatio * dampingRatio);\n        // Underdamped spring (bouncy)\n        resolveSpring = (t) => to -\n            Math.exp(-dampingRatio * undampedAngularFreq * t) *\n                (((-velocity + dampingRatio * undampedAngularFreq * initialDelta) /\n                    angularFreq) *\n                    Math.sin(angularFreq * t) +\n                    initialDelta * Math.cos(angularFreq * t));\n    }\n    else {\n        // Critically damped spring\n        resolveSpring = (t) => {\n            return (to -\n                Math.exp(-undampedAngularFreq * t) *\n                    (initialDelta + (-velocity + undampedAngularFreq * initialDelta) * t));\n        };\n    }\n    return (t) => {\n        state.current = resolveSpring(t);\n        const currentVelocity = t === 0\n            ? velocity\n            : calcGeneratorVelocity(resolveSpring, t, state.current);\n        const isBelowVelocityThreshold = Math.abs(currentVelocity) <= restSpeed;\n        const isBelowDisplacementThreshold = Math.abs(to - state.current) <= restDistance;\n        state.done = isBelowVelocityThreshold && isBelowDisplacementThreshold;\n        state.hasReachedTarget = hasReachedTarget(from, to, state.current);\n        return state;\n    };\n};\n\nexport { spring };\n", "import { time } from '@motionone/utils';\nimport { calcGeneratorVelocity } from '../utils/velocity.es.js';\nimport { spring } from '../spring/index.es.js';\n\nconst glide = ({ from = 0, velocity = 0.0, power = 0.8, decay = 0.325, bounceDamping, bounceStiffness, changeTarget, min, max, restDistance = 0.5, restSpeed, }) => {\n    decay = time.ms(decay);\n    const state = {\n        hasReachedTarget: false,\n        done: false,\n        current: from,\n        target: from,\n    };\n    const isOutOfBounds = (v) => (min !== undefined && v < min) || (max !== undefined && v > max);\n    const nearestBoundary = (v) => {\n        if (min === undefined)\n            return max;\n        if (max === undefined)\n            return min;\n        return Math.abs(min - v) < Math.abs(max - v) ? min : max;\n    };\n    let amplitude = power * velocity;\n    const ideal = from + amplitude;\n    const target = changeTarget === undefined ? ideal : changeTarget(ideal);\n    state.target = target;\n    /**\n     * If the target has changed we need to re-calculate the amplitude, otherwise\n     * the animation will start from the wrong position.\n     */\n    if (target !== ideal)\n        amplitude = target - from;\n    const calcDelta = (t) => -amplitude * Math.exp(-t / decay);\n    const calcLatest = (t) => target + calcDelta(t);\n    const applyFriction = (t) => {\n        const delta = calcDelta(t);\n        const latest = calcLatest(t);\n        state.done = Math.abs(delta) <= restDistance;\n        state.current = state.done ? target : latest;\n    };\n    /**\n     * Ideally this would resolve for t in a stateless way, we could\n     * do that by always precalculating the animation but as we know\n     * this will be done anyway we can assume that spring will\n     * be discovered during that.\n     */\n    let timeReachedBoundary;\n    let spring$1;\n    const checkCatchBoundary = (t) => {\n        if (!isOutOfBounds(state.current))\n            return;\n        timeReachedBoundary = t;\n        spring$1 = spring({\n            from: state.current,\n            to: nearestBoundary(state.current),\n            velocity: calcGeneratorVelocity(calcLatest, t, state.current),\n            damping: bounceDamping,\n            stiffness: bounceStiffness,\n            restDistance,\n            restSpeed,\n        });\n    };\n    checkCatchBoundary(0);\n    return (t) => {\n        /**\n         * We need to resolve the friction to figure out if we need a\n         * spring but we don't want to do this twice per frame. So here\n         * we flag if we updated for this frame and later if we did\n         * we can skip doing it again.\n         */\n        let hasUpdatedFrame = false;\n        if (!spring$1 && timeReachedBoundary === undefined) {\n            hasUpdatedFrame = true;\n            applyFriction(t);\n            checkCatchBoundary(t);\n        }\n        /**\n         * If we have a spring and the provided t is beyond the moment the friction\n         * animation crossed the min/max boundary, use the spring.\n         */\n        if (timeReachedBoundary !== undefined && t > timeReachedBoundary) {\n            state.hasReachedTarget = true;\n            return spring$1(t - timeReachedBoundary);\n        }\n        else {\n            state.hasReachedTarget = false;\n            !hasUpdatedFrame && applyFriction(t);\n            return state;\n        }\n    };\n};\n\nexport { glide };\n", "import { noopReturn } from '@motionone/utils';\n\nconst timeStep = 10;\nconst maxDuration = 10000;\nfunction pregenerateKeyframes(generator, toUnit = noopReturn) {\n    let overshootDuration = undefined;\n    let timestamp = timeStep;\n    let state = generator(0);\n    const keyframes = [toUnit(state.current)];\n    while (!state.done && timestamp < maxDuration) {\n        state = generator(timestamp);\n        keyframes.push(toUnit(state.done ? state.target : state.current));\n        if (overshootDuration === undefined && state.hasReachedTarget) {\n            overshootDuration = timestamp;\n        }\n        timestamp += timeStep;\n    }\n    const duration = timestamp - timeStep;\n    /**\n     * If generating an animation that didn't actually move,\n     * generate a second keyframe so we have an origin and target.\n     */\n    if (keyframes.length === 1)\n        keyframes.push(state.current);\n    return {\n        keyframes,\n        duration: duration / 1000,\n        overshootDuration: (overshootDuration !== null && overshootDuration !== void 0 ? overshootDuration : duration) / 1000,\n    };\n}\n\nexport { pregenerateKeyframes };\n", "import { calcGeneratorVelocity, pregenerateKeyframes } from '@motionone/generators';\nimport { isNumber, isString, noopReturn } from '@motionone/utils';\nimport { getUnitConverter } from '../animate/utils/get-unit.es.js';\nimport { transformDefinitions } from '../animate/utils/transforms.es.js';\nimport { getStyleName } from '../animate/utils/get-style-name.es.js';\n\nfunction canGenerate(value) {\n    return isNumber(value) && !isNaN(value);\n}\nfunction getAsNumber(value) {\n    return isString(value) ? parseFloat(value) : value;\n}\nfunction createGeneratorEasing(createGenerator) {\n    const keyframesCache = new WeakMap();\n    return (options = {}) => {\n        const generatorCache = new Map();\n        const getGenerator = (from = 0, to = 100, velocity = 0, isScale = false) => {\n            const key = `${from}-${to}-${velocity}-${isScale}`;\n            if (!generatorCache.has(key)) {\n                generatorCache.set(key, createGenerator(Object.assign({ from,\n                    to,\n                    velocity }, options)));\n            }\n            return generatorCache.get(key);\n        };\n        const getKeyframes = (generator, toUnit) => {\n            if (!keyframesCache.has(generator)) {\n                keyframesCache.set(generator, pregenerateKeyframes(generator, toUnit));\n            }\n            return keyframesCache.get(generator);\n        };\n        return {\n            createAnimation: (keyframes, shouldGenerate = true, getOrigin, name, motionValue) => {\n                let settings;\n                let origin;\n                let target;\n                let velocity = 0;\n                let toUnit = noopReturn;\n                const numKeyframes = keyframes.length;\n                /**\n                 * If we should generate an animation for this value, run some preperation\n                 * like resolving target/origin, finding a unit (if any) and determine if\n                 * it is actually possible to generate.\n                 */\n                if (shouldGenerate) {\n                    toUnit = getUnitConverter(keyframes, name ? transformDefinitions.get(getStyleName(name)) : undefined);\n                    const targetDefinition = keyframes[numKeyframes - 1];\n                    target = getAsNumber(targetDefinition);\n                    if (numKeyframes > 1 && keyframes[0] !== null) {\n                        /**\n                         * If we have multiple keyframes, take the initial keyframe as the origin.\n                         */\n                        origin = getAsNumber(keyframes[0]);\n                    }\n                    else {\n                        const prevGenerator = motionValue === null || motionValue === void 0 ? void 0 : motionValue.generator;\n                        /**\n                         * If we have an existing generator for this value we can use it to resolve\n                         * the animation's current value and velocity.\n                         */\n                        if (prevGenerator) {\n                            /**\n                             * If we have a generator for this value we can use it to resolve\n                             * the animations's current value and velocity.\n                             */\n                            const { animation, generatorStartTime } = motionValue;\n                            const startTime = (animation === null || animation === void 0 ? void 0 : animation.startTime) || generatorStartTime || 0;\n                            const currentTime = (animation === null || animation === void 0 ? void 0 : animation.currentTime) || performance.now() - startTime;\n                            const prevGeneratorCurrent = prevGenerator(currentTime).current;\n                            origin = prevGeneratorCurrent;\n                            velocity = calcGeneratorVelocity((t) => prevGenerator(t).current, currentTime, prevGeneratorCurrent);\n                        }\n                        else if (getOrigin) {\n                            /**\n                             * As a last resort, read the origin from the DOM.\n                             */\n                            origin = getAsNumber(getOrigin());\n                        }\n                    }\n                }\n                /**\n                 * If we've determined it is possible to generate an animation, do so.\n                 */\n                if (canGenerate(origin) && canGenerate(target)) {\n                    const generator = getGenerator(origin, target, velocity, name === null || name === void 0 ? void 0 : name.includes(\"scale\"));\n                    settings = Object.assign(Object.assign({}, getKeyframes(generator, toUnit)), { easing: \"linear\" });\n                    // TODO Add test for this\n                    if (motionValue) {\n                        motionValue.generator = generator;\n                        motionValue.generatorStartTime = performance.now();\n                    }\n                }\n                /**\n                 * If by now we haven't generated a set of keyframes, create a generic generator\n                 * based on the provided props that animates from 0-100 to fetch a rough\n                 * \"overshootDuration\" - the moment when the generator first hits the animation target.\n                 * Then return animation settings that will run a normal animation for that duration.\n                 */\n                if (!settings) {\n                    const keyframesMetadata = getKeyframes(getGenerator(0, 100));\n                    settings = {\n                        easing: \"ease\",\n                        duration: keyframesMetadata.overshootDuration,\n                    };\n                }\n                return settings;\n            },\n        };\n    };\n}\n\nexport { createGeneratorEasing };\n", "import { spring as spring$1 } from '@motionone/generators';\nimport { createGeneratorEasing } from '../create-generator-easing.es.js';\n\nconst spring = createGeneratorEasing(spring$1);\n\nexport { spring };\n", "import { glide as glide$1 } from '@motionone/generators';\nimport { createGeneratorEasing } from '../create-generator-easing.es.js';\n\nconst glide = createGeneratorEasing(glide$1);\n\nexport { glide };\n", "import { resolveElements } from '../utils/resolve-elements.es.js';\nimport { isFunction } from '@motionone/utils';\n\nconst thresholds = {\n    any: 0,\n    all: 1,\n};\nfunction inView(elementOrSelector, onStart, { root, margin: rootMargin, amount = \"any\" } = {}) {\n    /**\n     * If this browser doesn't support IntersectionObserver, return a dummy stop function.\n     * Default triggering of onStart is tricky - it could be used for starting/stopping\n     * videos, lazy loading content etc. We could provide an option to enable a fallback, or\n     * provide a fallback callback option.\n     */\n    if (typeof IntersectionObserver === \"undefined\") {\n        return () => { };\n    }\n    const elements = resolveElements(elementOrSelector);\n    const activeIntersections = new WeakMap();\n    const onIntersectionChange = (entries) => {\n        entries.forEach((entry) => {\n            const onEnd = activeIntersections.get(entry.target);\n            /**\n             * If there's no change to the intersection, we don't need to\n             * do anything here.\n             */\n            if (entry.isIntersecting === Boolean(onEnd))\n                return;\n            if (entry.isIntersecting) {\n                const newOnEnd = onStart(entry);\n                if (isFunction(newOnEnd)) {\n                    activeIntersections.set(entry.target, newOnEnd);\n                }\n                else {\n                    observer.unobserve(entry.target);\n                }\n            }\n            else if (onEnd) {\n                onEnd(entry);\n                activeIntersections.delete(entry.target);\n            }\n        });\n    };\n    const observer = new IntersectionObserver(onIntersectionChange, {\n        root,\n        rootMargin,\n        threshold: typeof amount === \"number\" ? amount : thresholds[amount],\n    });\n    elements.forEach((element) => observer.observe(element));\n    return () => observer.disconnect();\n}\n\nexport { inView };\n", "import { resolveElements } from '../../utils/resolve-elements.es.js';\n\nconst resizeHandlers = new WeakMap();\nlet observer;\nfunction getElementSize(target, borderBoxSize) {\n    if (borderBoxSize) {\n        const { inlineSize, blockSize } = borderBoxSize[0];\n        return { width: inlineSize, height: blockSize };\n    }\n    else if (target instanceof SVGElement && \"getBBox\" in target) {\n        return target.getBBox();\n    }\n    else {\n        return {\n            width: target.offsetWidth,\n            height: target.offsetHeight,\n        };\n    }\n}\nfunction notifyTarget({ target, contentRect, borderBoxSize, }) {\n    var _a;\n    (_a = resizeHandlers.get(target)) === null || _a === void 0 ? void 0 : _a.forEach((handler) => {\n        handler({\n            target,\n            contentSize: contentRect,\n            get size() {\n                return getElementSize(target, borderBoxSize);\n            },\n        });\n    });\n}\nfunction notifyAll(entries) {\n    entries.forEach(notifyTarget);\n}\nfunction createResizeObserver() {\n    if (typeof ResizeObserver === \"undefined\")\n        return;\n    observer = new ResizeObserver(notifyAll);\n}\nfunction resizeElement(target, handler) {\n    if (!observer)\n        createResizeObserver();\n    const elements = resolveElements(target);\n    elements.forEach((element) => {\n        let elementHandlers = resizeHandlers.get(element);\n        if (!elementHandlers) {\n            elementHandlers = new Set();\n            resizeHandlers.set(element, elementHandlers);\n        }\n        elementHandlers.add(handler);\n        observer === null || observer === void 0 ? void 0 : observer.observe(element);\n    });\n    return () => {\n        elements.forEach((element) => {\n            const elementHandlers = resizeHandlers.get(element);\n            elementHandlers === null || elementHandlers === void 0 ? void 0 : elementHandlers.delete(handler);\n            if (!(elementHandlers === null || elementHandlers === void 0 ? void 0 : elementHandlers.size)) {\n                observer === null || observer === void 0 ? void 0 : observer.unobserve(element);\n            }\n        });\n    };\n}\n\nexport { resizeElement };\n", "const windowCallbacks = new Set();\nlet windowResizeHandler;\nfunction createWindowResizeHandler() {\n    windowResizeHandler = () => {\n        const size = {\n            width: window.innerWidth,\n            height: window.innerHeight,\n        };\n        const info = {\n            target: window,\n            size,\n            contentSize: size,\n        };\n        windowCallbacks.forEach((callback) => callback(info));\n    };\n    window.addEventListener(\"resize\", windowResizeHandler);\n}\nfunction resizeWindow(callback) {\n    windowCallbacks.add(callback);\n    if (!windowResizeHandler)\n        createWindowResizeHandler();\n    return () => {\n        windowCallbacks.delete(callback);\n        if (!windowCallbacks.size && windowResizeHandler) {\n            windowResizeHandler = undefined;\n        }\n    };\n}\n\nexport { resizeWindow };\n", "import { resizeElement } from './handle-element.es.js';\nimport { resizeWindow } from './handle-window.es.js';\nimport { isFunction } from '@motionone/utils';\n\nfunction resize(a, b) {\n    return isFunction(a) ? resizeWindow(a) : resizeElement(a, b);\n}\n\nexport { resize };\n", "import { progress, velocityPerSecond } from '@motionone/utils';\n\n/**\n * A time in milliseconds, beyond which we consider the scroll velocity to be 0.\n */\nconst maxElapsed = 50;\nconst createAxisInfo = () => ({\n    current: 0,\n    offset: [],\n    progress: 0,\n    scrollLength: 0,\n    targetOffset: 0,\n    targetLength: 0,\n    containerLength: 0,\n    velocity: 0,\n});\nconst createScrollInfo = () => ({\n    time: 0,\n    x: createAxisInfo(),\n    y: createAxisInfo(),\n});\nconst keys = {\n    x: {\n        length: \"Width\",\n        position: \"Left\",\n    },\n    y: {\n        length: \"Height\",\n        position: \"Top\",\n    },\n};\nfunction updateAxisInfo(element, axisName, info, time) {\n    const axis = info[axisName];\n    const { length, position } = keys[axisName];\n    const prev = axis.current;\n    const prevTime = info.time;\n    axis.current = element[\"scroll\" + position];\n    axis.scrollLength = element[\"scroll\" + length] - element[\"client\" + length];\n    axis.offset.length = 0;\n    axis.offset[0] = 0;\n    axis.offset[1] = axis.scrollLength;\n    axis.progress = progress(0, axis.scrollLength, axis.current);\n    const elapsed = time - prevTime;\n    axis.velocity =\n        elapsed > maxElapsed ? 0 : velocityPerSecond(axis.current - prev, elapsed);\n}\nfunction updateScrollInfo(element, info, time) {\n    updateAxisInfo(element, \"x\", info, time);\n    updateAxisInfo(element, \"y\", info, time);\n    info.time = time;\n}\n\nexport { createScrollInfo, updateScrollInfo };\n", "function calcInset(element, container) {\n    let inset = { x: 0, y: 0 };\n    let current = element;\n    while (current && current !== container) {\n        if (current instanceof HTMLElement) {\n            inset.x += current.offsetLeft;\n            inset.y += current.offsetTop;\n            current = current.offsetParent;\n        }\n        else if (current instanceof SVGGraphicsElement && \"getBBox\" in current) {\n            const { top, left } = current.getBBox();\n            inset.x += left;\n            inset.y += top;\n            /**\n             * Assign the next parent element as the <svg /> tag.\n             */\n            while (current && current.tagName !== \"svg\") {\n                current = current.parentNode;\n            }\n        }\n    }\n    return inset;\n}\n\nexport { calcInset };\n", "const ScrollOffset = {\n    Enter: [\n        [0, 1],\n        [1, 1],\n    ],\n    Exit: [\n        [0, 0],\n        [1, 0],\n    ],\n    Any: [\n        [1, 0],\n        [0, 1],\n    ],\n    All: [\n        [0, 0],\n        [1, 1],\n    ],\n};\n\nexport { ScrollOffset };\n", "import { isString, isNumber } from '@motionone/utils';\n\nconst namedEdges = {\n    start: 0,\n    center: 0.5,\n    end: 1,\n};\nfunction resolveEdge(edge, length, inset = 0) {\n    let delta = 0;\n    /**\n     * If we have this edge defined as a preset, replace the definition\n     * with the numerical value.\n     */\n    if (namedEdges[edge] !== undefined) {\n        edge = namedEdges[edge];\n    }\n    /**\n     * Handle unit values\n     */\n    if (isString(edge)) {\n        const asNumber = parseFloat(edge);\n        if (edge.endsWith(\"px\")) {\n            delta = asNumber;\n        }\n        else if (edge.endsWith(\"%\")) {\n            edge = asNumber / 100;\n        }\n        else if (edge.endsWith(\"vw\")) {\n            delta = (asNumber / 100) * document.documentElement.clientWidth;\n        }\n        else if (edge.endsWith(\"vh\")) {\n            delta = (asNumber / 100) * document.documentElement.clientHeight;\n        }\n        else {\n            edge = asNumber;\n        }\n    }\n    /**\n     * If the edge is defined as a number, handle as a progress value.\n     */\n    if (isNumber(edge)) {\n        delta = length * edge;\n    }\n    return inset + delta;\n}\n\nexport { namedEdges, resolveEdge };\n", "import { isNumber, isString } from '@motionone/utils';\nimport { resolveEdge, namedEdges } from './edge.es.js';\n\nconst defaultOffset = [0, 0];\nfunction resolveOffset(offset, containerLength, targetLength, targetInset) {\n    let offsetDefinition = Array.isArray(offset) ? offset : defaultOffset;\n    let targetPoint = 0;\n    let containerPoint = 0;\n    if (isNumber(offset)) {\n        /**\n         * If we're provided offset: [0, 0.5, 1] then each number x should become\n         * [x, x], so we default to the behaviour of mapping 0 => 0 of both target\n         * and container etc.\n         */\n        offsetDefinition = [offset, offset];\n    }\n    else if (isString(offset)) {\n        offset = offset.trim();\n        if (offset.includes(\" \")) {\n            offsetDefinition = offset.split(\" \");\n        }\n        else {\n            /**\n             * If we're provided a definition like \"100px\" then we want to apply\n             * that only to the top of the target point, leaving the container at 0.\n             * Whereas a named offset like \"end\" should be applied to both.\n             */\n            offsetDefinition = [offset, namedEdges[offset] ? offset : `0`];\n        }\n    }\n    targetPoint = resolveEdge(offsetDefinition[0], targetLength, targetInset);\n    containerPoint = resolveEdge(offsetDefinition[1], containerLength);\n    return targetPoint - containerPoint;\n}\n\nexport { resolveOffset };\n", "import { interpolate, defaultOffset } from '@motionone/utils';\nimport { calcInset } from './inset.es.js';\nimport { ScrollOffset } from './presets.es.js';\nimport { resolveOffset } from './offset.es.js';\n\nconst point = { x: 0, y: 0 };\nfunction resolveOffsets(container, info, options) {\n    let { offset: offsetDefinition = ScrollOffset.All } = options;\n    const { target = container, axis = \"y\" } = options;\n    const lengthLabel = axis === \"y\" ? \"height\" : \"width\";\n    const inset = target !== container ? calcInset(target, container) : point;\n    /**\n     * Measure the target and container. If they're the same thing then we\n     * use the container's scrollWidth/Height as the target, from there\n     * all other calculations can remain the same.\n     */\n    const targetSize = target === container\n        ? { width: container.scrollWidth, height: container.scrollHeight }\n        : { width: target.clientWidth, height: target.clientHeight };\n    const containerSize = {\n        width: container.clientWidth,\n        height: container.clientHeight,\n    };\n    /**\n     * Reset the length of the resolved offset array rather than creating a new one.\n     * TODO: More reusable data structures for targetSize/containerSize would also be good.\n     */\n    info[axis].offset.length = 0;\n    /**\n     * Populate the offset array by resolving the user's offset definition into\n     * a list of pixel scroll offets.\n     */\n    let hasChanged = !info[axis].interpolate;\n    const numOffsets = offsetDefinition.length;\n    for (let i = 0; i < numOffsets; i++) {\n        const offset = resolveOffset(offsetDefinition[i], containerSize[lengthLabel], targetSize[lengthLabel], inset[axis]);\n        if (!hasChanged && offset !== info[axis].interpolatorOffsets[i]) {\n            hasChanged = true;\n        }\n        info[axis].offset[i] = offset;\n    }\n    /**\n     * If the pixel scroll offsets have changed, create a new interpolator function\n     * to map scroll value into a progress.\n     */\n    if (hasChanged) {\n        info[axis].interpolate = interpolate(defaultOffset(numOffsets), info[axis].offset);\n        info[axis].interpolatorOffsets = [...info[axis].offset];\n    }\n    info[axis].progress = info[axis].interpolate(info[axis].current);\n}\n\nexport { resolveOffsets };\n", "import { isFunction, noopReturn } from '@motionone/utils';\nimport { updateScrollInfo } from './info.es.js';\nimport { resolveOffsets } from './offsets/index.es.js';\n\nfunction measure(container, target = container, info) {\n    /**\n     * Find inset of target within scrollable container\n     */\n    info.x.targetOffset = 0;\n    info.y.targetOffset = 0;\n    if (target !== container) {\n        let node = target;\n        while (node && node != container) {\n            info.x.targetOffset += node.offsetLeft;\n            info.y.targetOffset += node.offsetTop;\n            node = node.offsetParent;\n        }\n    }\n    info.x.targetLength =\n        target === container ? target.scrollWidth : target.clientWidth;\n    info.y.targetLength =\n        target === container ? target.scrollHeight : target.clientHeight;\n    info.x.containerLength = container.clientWidth;\n    info.y.containerLength = container.clientHeight;\n}\nfunction createOnScrollHandler(element, onScroll, info, options = {}) {\n    const axis = options.axis || \"y\";\n    return {\n        measure: () => measure(element, options.target, info),\n        update: (time) => {\n            updateScrollInfo(element, info, time);\n            if (options.offset || options.target) {\n                resolveOffsets(element, info, options);\n            }\n        },\n        notify: isFunction(onScroll)\n            ? () => onScroll(info)\n            : scrubAnimation(onScroll, info[axis]),\n    };\n}\nfunction scrubAnimation(controls, axisInfo) {\n    controls.pause();\n    controls.forEachNative((animation, { easing }) => {\n        var _a, _b;\n        if (animation.updateDuration) {\n            if (!easing)\n                animation.easing = noopReturn;\n            animation.updateDuration(1);\n        }\n        else {\n            const timingOptions = { duration: 1000 };\n            if (!easing)\n                timingOptions.easing = \"linear\";\n            (_b = (_a = animation.effect) === null || _a === void 0 ? void 0 : _a.updateTiming) === null || _b === void 0 ? void 0 : _b.call(_a, timingOptions);\n        }\n    });\n    return () => {\n        controls.currentTime = axisInfo.progress;\n    };\n}\n\nexport { createOnScrollHandler };\n", "import { __rest } from 'tslib';\nimport { resize } from '../resize/index.es.js';\nimport { createScrollInfo } from './info.es.js';\nimport { createOnScrollHandler } from './on-scroll-handler.es.js';\n\nconst scrollListeners = new WeakMap();\nconst resizeListeners = new WeakMap();\nconst onScrollHandlers = new WeakMap();\nconst getEventTarget = (element) => element === document.documentElement ? window : element;\nfunction scroll(onScroll, _a = {}) {\n    var { container = document.documentElement } = _a, options = __rest(_a, [\"container\"]);\n    let containerHandlers = onScrollHandlers.get(container);\n    /**\n     * Get the onScroll handlers for this container.\n     * If one isn't found, create a new one.\n     */\n    if (!containerHandlers) {\n        containerHandlers = new Set();\n        onScrollHandlers.set(container, containerHandlers);\n    }\n    /**\n     * Create a new onScroll handler for the provided callback.\n     */\n    const info = createScrollInfo();\n    const containerHandler = createOnScrollHandler(container, onScroll, info, options);\n    containerHandlers.add(containerHandler);\n    /**\n     * Check if there's a scroll event listener for this container.\n     * If not, create one.\n     */\n    if (!scrollListeners.has(container)) {\n        const listener = () => {\n            const time = performance.now();\n            for (const handler of containerHandlers)\n                handler.measure();\n            for (const handler of containerHandlers)\n                handler.update(time);\n            for (const handler of containerHandlers)\n                handler.notify();\n        };\n        scrollListeners.set(container, listener);\n        const target = getEventTarget(container);\n        window.addEventListener(\"resize\", listener, { passive: true });\n        if (container !== document.documentElement) {\n            resizeListeners.set(container, resize(container, listener));\n        }\n        target.addEventListener(\"scroll\", listener, { passive: true });\n    }\n    const listener = scrollListeners.get(container);\n    const onLoadProcesss = requestAnimationFrame(listener);\n    return () => {\n        var _a;\n        if (typeof onScroll !== \"function\")\n            onScroll.stop();\n        cancelAnimationFrame(onLoadProcesss);\n        /**\n         * Check if we even have any handlers for this container.\n         */\n        const containerHandlers = onScrollHandlers.get(container);\n        if (!containerHandlers)\n            return;\n        containerHandlers.delete(containerHandler);\n        if (containerHandlers.size)\n            return;\n        /**\n         * If no more handlers, remove the scroll listener too.\n         */\n        const listener = scrollListeners.get(container);\n        scrollListeners.delete(container);\n        if (listener) {\n            getEventTarget(container).removeEventListener(\"scroll\", listener);\n            (_a = resizeListeners.get(container)) === null || _a === void 0 ? void 0 : _a();\n            window.removeEventListener(\"resize\", listener);\n        }\n    };\n}\n\nexport { scroll };\n", "function hasChanged(a, b) {\n    if (typeof a !== typeof b)\n        return true;\n    if (Array.isArray(a) && Array.isArray(b))\n        return !shallowCompare(a, b);\n    return a !== b;\n}\nfunction shallowCompare(next, prev) {\n    const prevLength = prev.length;\n    if (prevLength !== next.length)\n        return false;\n    for (let i = 0; i < prevLength; i++) {\n        if (prev[i] !== next[i])\n            return false;\n    }\n    return true;\n}\n\nexport { hasChanged, shallowCompare };\n", "function isVariant(definition) {\n    return typeof definition === \"object\";\n}\n\nexport { isVariant };\n", "import { isVariant } from './is-variant.es.js';\n\nfunction resolveVariant(definition, variants) {\n    if (isVariant(definition)) {\n        return definition;\n    }\n    else if (definition && variants) {\n        return variants[definition];\n    }\n}\n\nexport { resolveVariant };\n", "import { addUniqueItem, removeItem } from '@motionone/utils';\n\nlet scheduled = undefined;\nfunction processScheduledAnimations() {\n    if (!scheduled)\n        return;\n    const generators = scheduled.sort(compareByDepth).map(fireAnimateUpdates);\n    generators.forEach(fireNext);\n    generators.forEach(fireNext);\n    scheduled = undefined;\n}\nfunction scheduleAnimation(state) {\n    if (!scheduled) {\n        scheduled = [state];\n        requestAnimationFrame(processScheduledAnimations);\n    }\n    else {\n        addUniqueItem(scheduled, state);\n    }\n}\nfunction unscheduleAnimation(state) {\n    scheduled && removeItem(scheduled, state);\n}\nconst compareByDepth = (a, b) => a.getDepth() - b.getDepth();\nconst fireAnimateUpdates = (state) => state.animateUpdates();\nconst fireNext = (iterator) => iterator.next();\n\nexport { scheduleAnimation, unscheduleAnimation };\n", "const motionEvent = (name, target) => new CustomEvent(name, { detail: { target } });\nfunction dispatchPointerEvent(element, name, event) {\n    element.dispatchEvent(new CustomEvent(name, { detail: { originalEvent: event } }));\n}\nfunction dispatchViewEvent(element, name, entry) {\n    element.dispatchEvent(new CustomEvent(name, { detail: { originalEntry: entry } }));\n}\n\nexport { dispatchPointerEvent, dispatchViewEvent, motionEvent };\n", "import { __rest } from 'tslib';\nimport { dispatchViewEvent } from '../utils/events.es.js';\nimport { inView as inView$1 } from '../../gestures/in-view.es.js';\n\nconst inView = {\n    isActive: (options) => Boolean(options.inView),\n    subscribe: (element, { enable, disable }, { inViewOptions = {} }) => {\n        const { once } = inViewOptions, viewOptions = __rest(inViewOptions, [\"once\"]);\n        return inView$1(element, (enterEntry) => {\n            enable();\n            dispatchViewEvent(element, \"viewenter\", enterEntry);\n            if (!once) {\n                return (leaveEntry) => {\n                    disable();\n                    dispatchViewEvent(element, \"viewleave\", leaveEntry);\n                };\n            }\n        }, viewOptions);\n    },\n};\n\nexport { inView };\n", "import { dispatchPointerEvent } from '../utils/events.es.js';\n\nconst mouseEvent = (element, name, action) => (event) => {\n    if (event.pointerType && event.pointerType !== \"mouse\")\n        return;\n    action();\n    dispatchPointerEvent(element, name, event);\n};\nconst hover = {\n    isActive: (options) => Boolean(options.hover),\n    subscribe: (element, { enable, disable }) => {\n        const onEnter = mouseEvent(element, \"hoverstart\", enable);\n        const onLeave = mouseEvent(element, \"hoverend\", disable);\n        element.addEventListener(\"pointerenter\", onEnter);\n        element.addEventListener(\"pointerleave\", onLeave);\n        return () => {\n            element.removeEventListener(\"pointerenter\", onEnter);\n            element.removeEventListener(\"pointerleave\", onLeave);\n        };\n    },\n};\n\nexport { hover };\n", "import { dispatchPointerEvent } from '../utils/events.es.js';\n\nconst press = {\n    isActive: (options) => Boolean(options.press),\n    subscribe: (element, { enable, disable }) => {\n        const onPointerUp = (event) => {\n            disable();\n            dispatchPointerEvent(element, \"pressend\", event);\n            window.removeEventListener(\"pointerup\", onPointerUp);\n        };\n        const onPointerDown = (event) => {\n            enable();\n            dispatchPointerEvent(element, \"pressstart\", event);\n            window.addEventListener(\"pointerup\", onPointerUp);\n        };\n        element.addEventListener(\"pointerdown\", onPointerDown);\n        return () => {\n            element.removeEventListener(\"pointerdown\", onPointerDown);\n            window.removeEventListener(\"pointerup\", onPointerUp);\n        };\n    },\n};\n\nexport { press };\n", "import { __rest } from 'tslib';\nimport { invariant } from 'hey-listen';\nimport { noop } from '@motionone/utils';\nimport { animateStyle } from '../animate/animate-style.es.js';\nimport { style } from '../animate/style.es.js';\nimport { getOptions } from '../animate/utils/options.es.js';\nimport { hasChanged } from './utils/has-changed.es.js';\nimport { resolveVariant } from './utils/resolve-variant.es.js';\nimport { scheduleAnimation, unscheduleAnimation } from './utils/schedule.es.js';\nimport { inView } from './gestures/in-view.es.js';\nimport { hover } from './gestures/hover.es.js';\nimport { press } from './gestures/press.es.js';\nimport { motionEvent } from './utils/events.es.js';\nimport { Animation } from '@motionone/animation';\n\nconst gestures = { inView, hover, press };\n/**\n * A list of state types, in priority order. If a value is defined in\n * a righter-most type, it will override any definition in a lefter-most.\n */\nconst stateTypes = [\"initial\", \"animate\", ...Object.keys(gestures), \"exit\"];\n/**\n * A global store of all generated motion states. This can be used to lookup\n * a motion state for a given Element.\n */\nconst mountedStates = new WeakMap();\nfunction createMotionState(options = {}, parent) {\n    /**\n     * The element represented by the motion state. This is an empty reference\n     * when we create the state to support SSR and allow for later mounting\n     * in view libraries.\n     *\n     * @ts-ignore\n     */\n    let element;\n    /**\n     * Calculate a depth that we can use to order motion states by tree depth.\n     */\n    let depth = parent ? parent.getDepth() + 1 : 0;\n    /**\n     * Track which states are currently active.\n     */\n    const activeStates = { initial: true, animate: true };\n    /**\n     * A map of functions that, when called, will remove event listeners for\n     * a given gesture.\n     */\n    const gestureSubscriptions = {};\n    /**\n     * Initialise a context to share through motion states. This\n     * will be populated by variant names (if any).\n     */\n    const context = {};\n    for (const name of stateTypes) {\n        context[name] =\n            typeof options[name] === \"string\"\n                ? options[name]\n                : parent === null || parent === void 0 ? void 0 : parent.getContext()[name];\n    }\n    /**\n     * If initial is set to false we use the animate prop as the initial\n     * animation state.\n     */\n    const initialVariantSource = options.initial === false ? \"animate\" : \"initial\";\n    /**\n     * Destructure an initial target out from the resolved initial variant.\n     */\n    let _a = resolveVariant(options[initialVariantSource] || context[initialVariantSource], options.variants) || {}, target = __rest(_a, [\"transition\"]);\n    /**\n     * The base target is a cached map of values that we'll use to animate\n     * back to if a value is removed from all active state types. This\n     * is usually the initial value as read from the DOM, for instance if\n     * it hasn't been defined in initial.\n     */\n    const baseTarget = Object.assign({}, target);\n    /**\n     * A generator that will be processed by the global animation scheduler.\n     * This yields when it switches from reading the DOM to writing to it\n     * to prevent layout thrashing.\n     */\n    function* animateUpdates() {\n        var _a, _b;\n        const prevTarget = target;\n        target = {};\n        const animationOptions = {};\n        for (const name of stateTypes) {\n            if (!activeStates[name])\n                continue;\n            const variant = resolveVariant(options[name]);\n            if (!variant)\n                continue;\n            for (const key in variant) {\n                if (key === \"transition\")\n                    continue;\n                target[key] = variant[key];\n                animationOptions[key] = getOptions((_b = (_a = variant.transition) !== null && _a !== void 0 ? _a : options.transition) !== null && _b !== void 0 ? _b : {}, key);\n            }\n        }\n        const allTargetKeys = new Set([\n            ...Object.keys(target),\n            ...Object.keys(prevTarget),\n        ]);\n        const animationFactories = [];\n        allTargetKeys.forEach((key) => {\n            var _a;\n            if (target[key] === undefined) {\n                target[key] = baseTarget[key];\n            }\n            if (hasChanged(prevTarget[key], target[key])) {\n                (_a = baseTarget[key]) !== null && _a !== void 0 ? _a : (baseTarget[key] = style.get(element, key));\n                animationFactories.push(animateStyle(element, key, target[key], animationOptions[key], Animation));\n            }\n        });\n        // Wait for all animation states to read from the DOM\n        yield;\n        const animations = animationFactories\n            .map((factory) => factory())\n            .filter(Boolean);\n        if (!animations.length)\n            return;\n        const animationTarget = target;\n        element.dispatchEvent(motionEvent(\"motionstart\", animationTarget));\n        Promise.all(animations.map((animation) => animation.finished))\n            .then(() => {\n            element.dispatchEvent(motionEvent(\"motioncomplete\", animationTarget));\n        })\n            .catch(noop);\n    }\n    const setGesture = (name, isActive) => () => {\n        activeStates[name] = isActive;\n        scheduleAnimation(state);\n    };\n    const updateGestureSubscriptions = () => {\n        for (const name in gestures) {\n            const isGestureActive = gestures[name].isActive(options);\n            const remove = gestureSubscriptions[name];\n            if (isGestureActive && !remove) {\n                gestureSubscriptions[name] = gestures[name].subscribe(element, {\n                    enable: setGesture(name, true),\n                    disable: setGesture(name, false),\n                }, options);\n            }\n            else if (!isGestureActive && remove) {\n                remove();\n                delete gestureSubscriptions[name];\n            }\n        }\n    };\n    const state = {\n        update: (newOptions) => {\n            if (!element)\n                return;\n            options = newOptions;\n            updateGestureSubscriptions();\n            scheduleAnimation(state);\n        },\n        setActive: (name, isActive) => {\n            if (!element)\n                return;\n            activeStates[name] = isActive;\n            scheduleAnimation(state);\n        },\n        animateUpdates,\n        getDepth: () => depth,\n        getTarget: () => target,\n        getOptions: () => options,\n        getContext: () => context,\n        mount: (newElement) => {\n            invariant(Boolean(newElement), \"Animation state must be mounted with valid Element\");\n            element = newElement;\n            mountedStates.set(element, state);\n            updateGestureSubscriptions();\n            return () => {\n                mountedStates.delete(element);\n                unscheduleAnimation(state);\n                for (const key in gestureSubscriptions) {\n                    gestureSubscriptions[key]();\n                }\n            };\n        },\n        isMounted: () => Boolean(element),\n    };\n    return state;\n}\n\nexport { createMotionState, mountedStates };\n", "import { isNumber } from '@motionone/utils';\nimport { isTransform, transformAlias, asTransformCssVar, transformDefinitions, buildTransformTemplate } from './transforms.es.js';\n\nfunction createStyles(keyframes) {\n    const initialKeyframes = {};\n    const transformKeys = [];\n    for (let key in keyframes) {\n        const value = keyframes[key];\n        if (isTransform(key)) {\n            if (transformAlias[key])\n                key = transformAlias[key];\n            transformKeys.push(key);\n            key = asTransformCssVar(key);\n        }\n        let initialKeyframe = Array.isArray(value) ? value[0] : value;\n        /**\n         * If this is a number and we have a default value type, convert the number\n         * to this type.\n         */\n        const definition = transformDefinitions.get(key);\n        if (definition) {\n            initialKeyframe = isNumber(value)\n                ? definition.toDefaultUnit(value)\n                : value;\n        }\n        initialKeyframes[key] = initialKeyframe;\n    }\n    if (transformKeys.length) {\n        initialKeyframes.transform = buildTransformTemplate(transformKeys);\n    }\n    return initialKeyframes;\n}\n\nexport { createStyles };\n", "import { createStyles } from './style-object.es.js';\n\nconst camelLetterToPipeLetter = (letter) => `-${letter.toLowerCase()}`;\nconst camelToPipeCase = (str) => str.replace(/[A-Z]/g, camelLetterToPipeLetter);\nfunction createStyleString(target = {}) {\n    const styles = createStyles(target);\n    let style = \"\";\n    for (const key in styles) {\n        style += key.startsWith(\"--\") ? key : camelToPipeCase(key);\n        style += `: ${styles[key]}; `;\n    }\n    return style;\n}\n\nexport { createStyleString };\n", "import { animate as animate$1, withControls } from '@motionone/dom';\nimport { isFunction } from '@motionone/utils';\nimport { Animation } from '@motionone/animation';\n\nfunction animateProgress(target, options = {}) {\n    return withControls([\n        () => {\n            const animation = new Animation(target, [0, 1], options);\n            animation.finished.catch(() => { });\n            return animation;\n        },\n    ], options, options.duration);\n}\nfunction animate(target, keyframesOrOptions, options) {\n    const factory = isFunction(target) ? animateProgress : animate$1;\n    return factory(target, keyframesOrOptions, options);\n}\n\nexport { animate, animateProgress };\n"],
  "mappings": "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",
  "names": ["progress", "steps", "progress", "progress", "transforms", "data", "animate", "definition", "maxDuration", "defaults", "defaults", "defaults", "spring", "glide", "observer", "time", "defaultOffset", "hasChanged", "time", "controls", "listener", "time", "_a", "containerHandlers", "inView", "inView", "_a", "style", "animate"]
}
